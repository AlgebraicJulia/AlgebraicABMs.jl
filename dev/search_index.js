var documenterSearchIndex = {"docs":
[{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"EditURL = \"../../literate/game_of_life.jl\"","category":"page"},{"location":"generated/game_of_life/#Conway's-Game-of-Life","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"","category":"section"},{"location":"generated/game_of_life/#Set-up","page":"Conway's Game of Life","title":"Set-up","text":"","category":"section"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"The first step of running a Julia program is to load the external libraries one will be using. We do this with a using statement.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"using AlgebraicABMs, Catlab, AlgebraicRewriting","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"We will turn on debug messages for AlgebraicABMs, which means we get to see what the ABM is thinking at each time step when we eventually run it.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"ENV[\"JULIA_DEBUG\"] = \"AlgebraicABMs\";\nnothing #hide","category":"page"},{"location":"generated/game_of_life/#Schema","page":"Conway's Game of Life","title":"Schema","text":"","category":"section"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"Defining an schema is stating what data is required to specify a state of the simulation at some point in time. In AlgebraicJulia, this is done via declaring a Presentation, i.e. a database schema. Objects (Ob, or tables) are types of entities. Homs (Hom, or foreign keys) are functional relationships between the aforementioned entities. AttrTypes are placeholders for Julia types, which are assigned to objects via attributes (Attr).","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"The schema below extends the schema for symmetric graphs, which consists in two tables (E and V, for edges and vertices) and homs (src, tgt) which relate the edges to the vertices. We consider each vertex to be a cell in the Game of Life. This is a generalization of the game, since it is not enforced that every cell has eight neighbors. However the example we run at the end will be a regular grid of vertices.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"Everything in the @present presentation below simply adds to the schema of symmetric graphs, indicated by the subtype operator <: SchSymmetricGraph. We need one more piece of information to specify a state of the world in the game of life: which cells are alive? There are a few ways one could distinguish the living cells from the dead ones. Here, we add a new table, Life which can be though of as a set of \"life tokens\". A function, live, assigns each such token to a cell, designating it to be alive. Thus the subset of living cells is the image of the live function.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"To summarize, a state of the world in the Game of Life is a set of cells (i.e. vertices), a set of edges (with src/tgt functions) which encode which cells are near each other, and a distinguished subset of cells given by the live function which marks which cells are alive. This information is summarized in the following graphical depiction of the schema.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"@present SchLifeGraph <: SchSymmetricGraph begin\n  Life::Ob\n  live::Hom(Life,V)\nend\n\nto_graphviz(SchLifeGraph) # visualize the schema","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"If SchLifeGraph is the piece of data which describes what it means to be a world state, we need a Julia datatype whose values are world staets.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"The @acset_type macro takes the specification of a datatype (i.e. a schema), and it generates an efficient Julia datatype, which is essentially the type of in-memory databases which have their schema given by SchLifeGraph.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"This line defines LifeState to be this new Julia type, and futhermore it states that it satisfies the AbstractSymmetricGraph interface: Catlab already has a lot of generic code to work with SymmetricGraph-like things, so now we are free to use it with LifeState.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"@acset_type LifeState(SchLifeGraph) <: AbstractSymmetricGraph;\nnothing #hide","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"Before we start defining the dynamics of our Game of Life, it'll be helpful to visualize states of the world. One thing that SchLifeGraph did not have was (x,y) coordinate information. Because we were representing proximity of vertices by the prescence or absence of an edge connecting them, these coordinates are irrelevant to the model dynamics.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"However, the coordinates are useful for visualization, so the below code creates a new schema which extends the previous one to add coordinates.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"@present SchLifeCoords <: SchLifeGraph begin\n  Coords::AttrType\n  coords::Attr(V, Coords)\nend\n\nto_graphviz(SchLifeCoords)","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"Likewise for this new schema, we need to use @acset_type to turn the description of the required data of a world state (the schema) into an actual Julia datatype. One difference here is that there is now an attribute present, which means we need to indicate what Julia type it should be.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"Our new Julia type is LifeStateCoords, and we pick Tuple{Int,Int} as our representation of (x,y) coordinates.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"@acset_type LifeStateCoords(SchLifeCoords){Tuple{Int,Int}} <: AbstractSymmetricGraph;\nnothing #hide","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"The following code is helpful for visualizing a game state. It's not important to understand this code in order to understand the model. It uses coordinates if the input is a LifeStateCoords, but otherwise it places the vertices in an arbitrary location.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"function view_life(X::Union{LifeState, LifeStateCoords}, pth=tempname())\n  pg = PropertyGraph{Any}(; prog=\"neato\", graph=Dict(),\n    node=Dict(:shape => \"circle\", :style => \"filled\", :margin => \"0\"),\n    edge=Dict(:dir => \"none\", :minlen => \"1\"))\n  add_vertices!(pg, nparts(X, :V))\n  for v in vertices(X)\n    is_alive = isempty(incident(X, v, :live))\n    set_vprop!(pg, v, :fillcolor, is_alive ? \"red\" : \"green\")\n    if X isa LifeStateCoords\n      x, y = X[v, :coords]\n      set_vprop!(pg, v, :pos, \"$x,$(y)!\")\n    end\n  end\n  for e in filter(e -> X[e, :inv] > e, edges(X))\n    add_edge!(pg, X[e, :src], X[e, :tgt])\n  end\n  G = to_graphviz(pg)\n  open(pth, \"w\") do io\n    show(io, \"image/svg+xml\", G)\n  end\n  return G\nend;\nnothing #hide","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"This helper function creates an ordinary, square grid and initializes cells as alive or dead via a boolean-valued input matrix. Like above, one does not need to understand this in order to understand the Game of Life model - it's just a convenient way to generate some initial states to run the model on.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"function make_grid(curr::AbstractMatrix)\n  n, m = size(curr)\n  n == m || error(\"Must be square\")\n  X, coords = LifeStateCoords(), Dict()\n  for j in 1:n, i in 1:n\n    coords[i=>j] = add_vertex!(X; coords=(i, j))\n    Bool(curr[i, j]) && add_part!(X, :Life, live=coords[i=>j])\n  end\n  for i in 1:n, j in 1:n\n    i < n && add_edge!(X, coords[i=>j], coords[i+1=>j])\n    j < n && add_edge!(X, coords[i=>j], coords[i=>j+1])\n    i < n && j < n && add_edge!(X, coords[i=>j], coords[i+1=>j+1])\n    i < n && j > 1 && add_edge!(X, coords[i=>j], coords[i+1=>j-1])\n  end\n  return X\nend;\nnothing #hide","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"Another helper function, which creates a game state on a square n × n grid. If the keyword random is true (which it is, by default), then cells have a 50% chance of being alive.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"Note: red color means that a cell is not in the image of the live function.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"make_grid(n::Int, random=true) =\n  make_grid((random ? rand : zeros)(Bool, (n, n)));\n\nview_life(make_grid(3)) # For example, visualize a random 3x3 grid","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"We've now constructed two schemas and two datatypes. No doubt they are related to each other, and AlgebraicJulia gives us the ability to take advantage of that relationship in order to automatically values of LifeStateCoords into values of LifeState (it does this is the obvious way: it throws away the coordinate information). More interestingly, it gives us a way of converting a LifeState into a LifeStateCoords: we give \"generic\" coordinates to each of the vertices.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"If we call AddCoords on something built out of LifeState instances, it will make the corresponding thing built out of LifeStateCoords instances.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"AddCoords = Migrate(SchLifeGraph, LifeState, SchLifeCoords, LifeStateCoords;\n                    delta=false);\nnothing #hide","category":"page"},{"location":"generated/game_of_life/#Initial-state-for-the-model","page":"Conway's Game of Life","title":"Initial state for the model","text":"","category":"section"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"With our make_grid function, it's easy to create an initial state.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"G = make_grid([0 1 0;\n               1 1 1;\n               0 1 0])\nview_life(G)","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"We'll use this world-state, called G throughout the model-building process to confirm our model building blocks work the way they're supposed to work.","category":"page"},{"location":"generated/game_of_life/#Building-blocks-for-the-Game-of-Life-model","page":"Conway's Game of Life","title":"Building blocks for the Game of Life model","text":"","category":"section"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"We are now ready to build our model, which will have three rules: underpopulation, overpopulation, and birth. When we write these rules down, it will be very succinct due to the hard work of this section: laying out the building blocks.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"Our first building block is an instance of LifeState. Now, we don't want to think of this as a particular state of the game of life, but rather we want to think of it as a pattern for which we could look for matches inside a real game state.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"This pattern is very simple: it consists of a single vertex. A match for this pattern in some world state X is just a choice of a vertex in X.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"const Cell = LifeState(1) # this syntax means: one vertex, nothing else\n\nview_life(Cell) # red color means this cell is not in image of `life` function.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"Let's confirm that this works. Our fancy word for \"pattern match\" is \"homomorphism\" (\"morphism\", for short). To look for morphisms from Cell into G is to ask \"find me all the cells!\". The Catlab function homomorphisms exhaustively finds all such answers to a query like this. When we run it below, we ought see there are 9 answers to this query, as there are 9 vertices in the 3 × 3 grid.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"length(homomorphisms(AddCoords(Cell), G))","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"Our next building block is also a LifeState instance that we think of as a pattern. It is a cell but, furthermore, it is a cell which has been marked as alive. This means it consists in one vertex, one 'life token', and the function live which maps Life₁ to V₁.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"const LiveCell = @acset LifeState begin V=1; Life=1; live=1 end\n\nview_life(LiveCell) # green color means this cell is in image of `life` function","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"Let's confirm that this works.  If we look for morphisms from LiveCell into G, meaning \"find me all the live cells!\", we will see there are 5 answers to this query","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"length(homomorphisms(AddCoords(LiveCell), G))","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"Now we will see our first morphism that is not between some pattern and some world state but, rather, is between our the two previous patterns. A morphism from Cell is an answer to the query \"give me a Cell!\" and there is exactly one possible answer to that query in LiveCell, thus we can use homomorphism, which returns an arbitrary morphism from the set of morphisms computed by homomorphisms.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"to_life is an important morphism to understand as it is the fundamental \"engine\" of the Game of Life. When read 'forwards', it expresses the idea of taking a vertex and adding a Life token to it. When read 'backwards', it expresses the idea of removing a Life token from a vertex. This is all we actually do when simulating the Game of Life: we toggle cells between being marked as alive vs no longer being marked as alive.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"const to_life = homomorphism(Cell, LiveCell);\nnothing #hide","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"The remaining challenge is to control the circumstances under which we perform this fundamental action of toggling life status. This is done via a technique called \"Positive (resp. negative) application conditions\". An application condition is a way of embedding a small pattern in a larger pattern (a context) with the assertion that, for a specific match of the small pattern in a world state, that this context is required (resp. forbidden) to hold.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"Here the small pattern, the large pattern, and the world state will all be LifeState instances. And the the 'embedding' of the small pattern into the large pattern as well as the match of the small pattern in the world will both be morphisms between LifeState instances.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"The following lines of code provide shorthand names for positive and negative applications. The use of the keyword monic can be ignored if this is your first time looking at AlgebraicJulia code. If not, the keyword indicates that the morphism (from the larger context to the world state, used to determine whether the application condition is satisfied) is required to be monic.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"PAC(m) = AppCond(m; monic=true) # Positive Application condition\nNAC(m) = AppCond(m, false; monic=true); # Negative Application condition\nnothing #hide","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"The following line provides a shorthand for constructing the fundamental building block of an ABM, which is an ABMRule. Such a rule requires a name, an instance of a rewrite Rule object from AlgebraicRewriting, as well as a timer which indicates the frequency at which the rule fires. All three of our rules will fire at every tick in time.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"TickRule(name, I_L, I_R; ac) = # Rule which fires on 1.0, 2.0, ...\n  ABMRule(name, Rule(I_L, I_R; ac), DiscreteHazard(1); schema=SchLifeGraph);\nnothing #hide","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"The context for determining whether the rules of underpopulation, overpopulation, or birth apply are always framed in terms of \"how many living neighbors do you have?\". Thus, it is helpful to have function which creates a context of n living neighbors which we can use with various values of n.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"Providing a context for a pattern is more than just giving an instance of LifeState; we also have to say how the pattern relates to the context. So our pattern here is either a vertex (if alive=false) or a vertex marked as alive (alive=true, which is the default value). This morphism data is what allows us to pick out the center vertex as the relevant starting point when checking if a particular match (which is a choice of a vertex in the game state) actually exists with that context of n living living neighbors.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"When we visualize the result of this function below, we're only visualizing the codomain of the morphism (i.e. what the morphism is pointing to).","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"function living_neighbors(n::Int; alive=true)::ACSetTransformation\n  X = LifeState(1)\n  alive && add_part!(X, :Life, live=1)\n  for _ in 1:n\n    v = add_part!(X, :V)\n    add_part!(X, :Life, live=v)\n    add_edge!(X, v, 1)\n  end\n  homomorphism(alive ? LiveCell : Cell, X; initial=(V=[1],))\nend;\n\nview_life(codom(living_neighbors(3; alive=false)))","category":"page"},{"location":"generated/game_of_life/#Create-model-by-defining-update-rules","page":"Conway's Game of Life","title":"Create model by defining update rules","text":"","category":"section"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"We now have our building blocks in place and can build the three rules.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"A rewrite rule is given by a pair of morphisms, L ← I → R. The first morphism is 'read backwards' (thought of as deletion), and the second one is 'read forwards' (thought of as addition). When one's rule does pure addition, the first morphism is an identity map. Likewise when one's rule does pure deletion, the second morphism is an identity map. So rules underpop and overpop will have their rule given by first to_life and then id(Cell), whereas the rule birth will first have id(Cell) and then to_life. The real interesting part of these constructions then is their application conditions (given via a keyword argument ac).","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"Let's start with underpopulation: a cell dies due to underpopulation if it has fewer than two living neighbors. So the application condition is a negative application: if we notice a cell has the context of two living neighbors, we should not apply the underpop rule.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"underpop =\n  TickRule(:Underpop, to_life, id(Cell); ac=[NAC(living_neighbors(2))]);\nnothing #hide","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"A cell dies due to overpopulation if it has over 3 living neighbors. So here our condition of applying the death rewrite (i.e. reading the morphism to_life backwards) is a positive application condition. We cannot kill a cell unless, furthermore, that cell is in a context where it has (at least) four living neighbors.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"overpop =\n  TickRule(:Overpop, to_life, id(Cell); ac=[PAC(living_neighbors(4))]);\nnothing #hide","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"The rule for birth is that one must have a dead cell with exactly three living neighbors. Our pattern here is simple a vertex, which could match any cell in the game state! So we need to use multiple application conditions to make sure the cell has at least three neighbors, fewer than four neighbors, and doesn't already have a life token. These three constraints are respectively the three elements of the list below.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"birth = TickRule(:Birth, id(Cell), to_life;\n                 ac=[PAC(living_neighbors(3; alive=false)),\n                     NAC(living_neighbors(4; alive=false)),\n                     NAC(to_life)]); # this rule does not apply if cell is alive\nnothing #hide","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"We can now create the model: an ABM is constituted by its transition rules","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"GoL = ABM(SchLifeGraph, [underpop, overpop, birth]);\nnothing #hide","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"We wrote an ABM for LifeState, but we want to apply it to G as its initial state. G is not a LifeState, but rather a LifeStateCoords! Luckily, we defined AddCoords earlier which knows how to migrate things in the language of LifeState into the language of LifeStateCoords.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"GoL_coords = AddCoords(GoL);\nnothing #hide","category":"page"},{"location":"generated/game_of_life/#Checking-our-rules-make-sense","page":"Conway's Game of Life","title":"Checking our rules make sense","text":"","category":"section"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"Let's remind ourselves what G looks like","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"view_life(G)","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"This code below counts how many matches a rule has, application conditions considered. It returns the coordinatees of those matches.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"match_coords(f::ACSetTransformation) =  codom(f)[f[:V](1), :coords]\nmatch_coords(rule::ABMRule, X) = match_coords.(get_matches(AddCoords(rule), X));\nnothing #hide","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"Let's calculate which cells will die from underpopulation in the first time step:","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"match_coords(underpop, G)","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"This is right, there are no living cells which have fewer than two living neighbors.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"Now, we see that the center cell dies from overpopulation:","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"match_coords(overpop, G)","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"Below are the coordinates of the four cells that will come to life:","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"match_coords(birth, G)","category":"page"},{"location":"generated/game_of_life/#Running-the-ABM","page":"Conway's Game of Life","title":"Running the ABM","text":"","category":"section"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"This is easy! Pass in our model and our initial state. We optionally could limit the run via some maximum number of steps or time, but this one will achieve steady state within 3 time steps.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"res = run!(GoL_coords, G);\nnothing #hide","category":"page"},{"location":"generated/game_of_life/#View-results","page":"Conway's Game of Life","title":"View results","text":"","category":"section"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"We use view_life to generate a bunch of images capturing the trajectory.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"imgs = view(res, view_life);\nnothing #hide","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"The first image is our starting point.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"imgs[1]","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"The next steps (all taking place at t=1.0) are the four births and one overpopulation death.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"imgs[2]","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"imgs[3]","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"imgs[4]","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"imgs[5]","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"imgs[6]","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"At this point, we move to t=2.0. There are now four cells which are overpopulated.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"imgs[7]","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"imgs[8]","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"imgs[9]","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"imgs[10]","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"In the last step, the remaining four living cells perish due to underpopulation.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"imgs[11]","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"imgs[12]","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"imgs[13]","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"imgs[14]","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/#Library-Reference","page":"Library Reference","title":"Library Reference","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"Modules = [\n  AlgebraicABMs.Distributions,\n  AlgebraicABMs.ABMs,\n]","category":"page"},{"location":"api/#AlgebraicABMs.Distributions.weibullpar-Tuple{Any, Any}","page":"Library Reference","title":"AlgebraicABMs.Distributions.weibullpar","text":"Get the shape and scale parameters for a Weibull distribution with a given mean and variance. This code is a translation of the R \"mixdist\" package's  function\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicABMs.ABMs.ABM","page":"Library Reference","title":"AlgebraicABMs.ABMs.ABM","text":"An agent-based model.\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicABMs.ABMs.ABMFlow","page":"Library Reference","title":"AlgebraicABMs.ABMs.ABMFlow","text":"Continuous dynamics\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicABMs.ABMs.ABMRule","page":"Library Reference","title":"AlgebraicABMs.ABMs.ABMRule","text":"A stochastic rewrite rule with a dependent hazard rate\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicABMs.ABMs.AbsDynamics","page":"Library Reference","title":"AlgebraicABMs.ABMs.AbsDynamics","text":"A type which implements AbsDynamics must be able to compiled to an ODE for some  set of variables.\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicABMs.ABMs.AbsHomSet","page":"Library Reference","title":"AlgebraicABMs.ABMs.AbsHomSet","text":"A collection of timers associated at runtime w/ an ABMRule\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicABMs.ABMs.AbsTimer","page":"Library Reference","title":"AlgebraicABMs.ABMs.AbsTimer","text":"Something that can produce a ACSetTransformation × clocktime → hazard_rate\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicABMs.ABMs.ClosureState","page":"Library Reference","title":"AlgebraicABMs.ABMs.ClosureState","text":"A closure which accepts a match morphism and returns a hazard_rate. This is a  timer which cannot depend on the absolute clock time.\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicABMs.ABMs.ClosureTime","page":"Library Reference","title":"AlgebraicABMs.ABMs.ClosureTime","text":"A closure which accepts a clocktime and returns a hazard_rate. This is a timer  which cannot depend on the match data nor ACSet state.\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicABMs.ABMs.EmptyP","page":"Library Reference","title":"AlgebraicABMs.ABMs.EmptyP","text":"Empty patterns have (one) trivial pattern match\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicABMs.ABMs.FullClosure","page":"Library Reference","title":"AlgebraicABMs.ABMs.FullClosure","text":"A closure which accepts a ACSetTransformation and returns a function of type clocktime → hazard_rate\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicABMs.ABMs.RegularP","page":"Library Reference","title":"AlgebraicABMs.ABMs.RegularP","text":"Default case, where pattern matches should be found via (incremental)  homomorphism search and represented explicitly, each with own events getting  scheduled.\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicABMs.ABMs.RepresentableP","page":"Library Reference","title":"AlgebraicABMs.ABMs.RepresentableP","text":"A pattern match from a coproduct of representables is just a choice of parts in the codomain. E.g. matching L = •→• • •  is just a random choice of edge and two random vertices.\n\nThe vector of ints refers to parts of L which are the counits of the left kan  extensions that define the representables (usually this is just wherever the  colimit leg sends 1, as there is often just one X part in the representable X).\n\nWARNING: this is only viable if the timer associated with the rewrite rule is symmteric with respect to the disjoint representables and has a simple exponential timer.\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicABMs.ABMs.RuntimeABM","page":"Library Reference","title":"AlgebraicABMs.ABMs.RuntimeABM","text":"Data @structhashequal structure for maintaining simulation information while running an ABM\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicABMs.ABMs.StockFlowDynamics","page":"Library Reference","title":"AlgebraicABMs.ABMs.StockFlowDynamics","text":"Use a Stock Flow diagram (possibly this could be in a package extension)\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicABMs.ABMs.Traj","page":"Library Reference","title":"AlgebraicABMs.ABMs.Traj","text":"A trajectory of an ABM: each event time and result of save.\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicABMs.ABMs.init_homset-Tuple{ABMRule, ACSets.ACSetInterface.ACSet, Vector{<:Catlab.CategoricalAlgebra.CSets.ACSetTransformation}, Union{Nothing, GATlab.Models.Presentations.Presentation}}","page":"Library Reference","title":"AlgebraicABMs.ABMs.init_homset","text":"Initialize runtime hom-set given the rule and the initial state\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicABMs.ABMs.is_exp-Tuple{Distributions.Exponential}","page":"Library Reference","title":"AlgebraicABMs.ABMs.is_exp","text":"Check if a hazard rate is a simple exponential\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicABMs.ABMs.pattern_type-Tuple{AlgebraicRewriting.Rewrite.Utils.Rule, Bool}","page":"Library Reference","title":"AlgebraicABMs.ABMs.pattern_type","text":"Analyze a pattern to find the most efficient pattern type for it.\n\nBecause ACSet types do not know their own equations, we may have to pass the  schema as an argument in order to compute representables that would otherwise  be infinite.\n\nEven if the pattern is a coproduct of representables, we cannot use the  efficient encoding unless the distribution is either an exponential  (or a single dirac delta - not yet supported).\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicABMs.ABMs.run!-Union{Tuple{T}, Tuple{ABM, T}} where T<:ACSets.ACSetInterface.ACSet","page":"Library Reference","title":"AlgebraicABMs.ABMs.run!","text":"Run an ABM, creating a fresh runtime + trajectory.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicABMs.ABMs.validate-Tuple{AlgebraicABMs.ABMs.RuntimeABM}","page":"Library Reference","title":"AlgebraicABMs.ABMs.validate","text":"Check that RuntimeABM incremental hom sets have all valid homs.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicABMs.Upstream.pops!-Tuple{AlgebraicABMs.ABMs.RuntimeABM}","page":"Library Reference","title":"AlgebraicABMs.Upstream.pops!","text":"Pop the next random event, advance the clock\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicRewriting.Rewrite.Utils.get_match-Tuple{AlgebraicABMs.ABMs.EmptyP, ACSets.ACSetInterface.ACSet, ACSets.ACSetInterface.ACSet, AlgebraicABMs.ABMs.EmptyHomSet, Nothing}","page":"Library Reference","title":"AlgebraicRewriting.Rewrite.Utils.get_match","text":"Get match returns a randomly chosen morphism for the aggregate rule\n\n\n\n\n\n","category":"method"},{"location":"generated/sir_petri/","page":"Petri-net based ABMs","title":"Petri-net based ABMs","text":"EditURL = \"../../literate/sir_petri.jl\"","category":"page"},{"location":"generated/sir_petri/#Petri-net-based-ABMs","page":"Petri-net based ABMs","title":"Petri-net based ABMs","text":"","category":"section"},{"location":"generated/sir_petri/","page":"Petri-net based ABMs","title":"Petri-net based ABMs","text":"First we want to load our packages with `using","category":"page"},{"location":"generated/sir_petri/","page":"Petri-net based ABMs","title":"Petri-net based ABMs","text":"using AlgebraicABMs, Catlab\nusing AlgebraicPetri\nusing Distributions, Makie, CairoMakie\nENV[\"JULIA_DEBUG\"] = \"\"; # turn off @debug messages for this package\nnothing #hide","category":"page"},{"location":"generated/sir_petri/","page":"Petri-net based ABMs","title":"Petri-net based ABMs","text":"We define an SIRS model with birth and death","category":"page"},{"location":"generated/sir_petri/","page":"Petri-net based ABMs","title":"Petri-net based ABMs","text":"sir_pn= @acset LabelledPetriNet begin\n  S=3; sname=[:S,:I,:R]\n  T=7; tname=[:inf,:rec,:birth,:deathS,:deathI,:deathR,:wane]\n  I=7; it=[1,1,2,4,5,6,7]; is=[1,2,2,1,2,3,3]\n  O=5; ot=[1,1,2,3,7]; os=[2,2,3,1,1]\nend;\nnothing #hide","category":"page"},{"location":"generated/sir_petri/","page":"Petri-net based ABMs","title":"Petri-net based ABMs","text":"We declare parameters to specify the random waiting times","category":"page"},{"location":"generated/sir_petri/","page":"Petri-net based ABMs","title":"Petri-net based ABMs","text":"pS, pI, pR = 95,5,0\npop = 100\nlifespan = 65*365\nμ = 1/lifespan\nβ = 0.001\nwane = 60;\nnothing #hide","category":"page"},{"location":"generated/sir_petri/","page":"Petri-net based ABMs","title":"Petri-net based ABMs","text":"Create the ABM by associating stochastic timers with each transition","category":"page"},{"location":"generated/sir_petri/","page":"Petri-net based ABMs","title":"Petri-net based ABMs","text":"abm = ABM(sir_pn, (inf=ContinuousHazard(1 / β),\n                   rec=ContinuousHazard(Weibull(weibullpar(30, 5)...)),\n                   birth=ContinuousHazard(1 / (μ*pop)),\n                   deathS=ContinuousHazard(1 / μ),\n                   deathI=ContinuousHazard(1 / μ),\n                   deathR=ContinuousHazard(1 / μ),\n                   wane=ContinuousHazard(wane)));\nnothing #hide","category":"page"},{"location":"generated/sir_petri/","page":"Petri-net based ABMs","title":"Petri-net based ABMs","text":"Initial state","category":"page"},{"location":"generated/sir_petri/","page":"Petri-net based ABMs","title":"Petri-net based ABMs","text":"init = PetriNetCSet(sir_pn; S=pS, I=pI)","category":"page"},{"location":"generated/sir_petri/","page":"Petri-net based ABMs","title":"Petri-net based ABMs","text":"Run the model","category":"page"},{"location":"generated/sir_petri/","page":"Petri-net based ABMs","title":"Petri-net based ABMs","text":"res = run!(abm, init; maxtime=2000);\nnothing #hide","category":"page"},{"location":"generated/sir_petri/","page":"Petri-net based ABMs","title":"Petri-net based ABMs","text":"Plot results","category":"page"},{"location":"generated/sir_petri/","page":"Petri-net based ABMs","title":"Petri-net based ABMs","text":"Makie.plot(res; Dict(o=>X->nparts(X,o) for o in [:S,:I,:R])...)","category":"page"},{"location":"generated/sir_petri/","page":"Petri-net based ABMs","title":"Petri-net based ABMs","text":"","category":"page"},{"location":"generated/sir_petri/","page":"Petri-net based ABMs","title":"Petri-net based ABMs","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#AlgebraicABMs.jl","page":"AlgebraicABMs.jl","title":"AlgebraicABMs.jl","text":"","category":"section"},{"location":"","page":"AlgebraicABMs.jl","title":"AlgebraicABMs.jl","text":"CurrentModule = AlgebraicABMs","category":"page"},{"location":"","page":"AlgebraicABMs.jl","title":"AlgebraicABMs.jl","text":"AlgebraicABMs.jl is a Julia library for creating agent-based models. We ultimate want to provide capabilities on par with software like AnyLogic, NetLogo, and Agents.jl - all while offering a mostly declarative interface such that: ","category":"page"},{"location":"","page":"AlgebraicABMs.jl","title":"AlgebraicABMs.jl","text":"The model's logic is transparent (rather than hidden away in complicated interactions of code blocks)\nModels can be built compositionally (we can naturally 'glue' models together at a high level, without worrying about implementation details and edge-cases)\nModels can be migrated at a high level, whether interpersonally (collaboration with others who have a different ontology/vocabulary) or intrapersonally (one updates one's own model of the of world and wishes to reuse one's old model under new assumptions, without having to manually refactor code and dig into implementation details).","category":"page"}]
}
