<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Lokta-Volterra, predator-prey model · AlgebraicABMs.jl</title><meta name="title" content="Lokta-Volterra, predator-prey model · AlgebraicABMs.jl"/><meta property="og:title" content="Lokta-Volterra, predator-prey model · AlgebraicABMs.jl"/><meta property="twitter:title" content="Lokta-Volterra, predator-prey model · AlgebraicABMs.jl"/><meta name="description" content="Documentation for AlgebraicABMs.jl."/><meta property="og:description" content="Documentation for AlgebraicABMs.jl."/><meta property="twitter:description" content="Documentation for AlgebraicABMs.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">AlgebraicABMs.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">AlgebraicABMs.jl</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../sir_petri/">Petri-net based ABMs</a></li><li><a class="tocitem" href="../game_of_life/">Conway&#39;s Game of Life</a></li><li class="is-active"><a class="tocitem" href>Lokta-Volterra, predator-prey model</a><ul class="internal"><li><a class="tocitem" href="#Set-up"><span>Set-up</span></a></li><li><a class="tocitem" href="#Schema"><span>Schema</span></a></li><li><a class="tocitem" href="#Initializing-and-visualizing-world-states"><span>Initializing and visualizing world states</span></a></li><li class="toplevel"><a class="tocitem" href="#Data-migration-functors"><span>Data migration functors</span></a></li><li class="toplevel"><a class="tocitem" href="#Representables"><span>Representables</span></a></li><li class="toplevel"><a class="tocitem" href="#Rules"><span>Rules</span></a></li><li class="toplevel"><a class="tocitem" href="#Adding-timers-to-the-rules-and-making-the-model"><span>Adding timers to the rules and making the model</span></a></li><li class="toplevel"><a class="tocitem" href="#Running-the-model"><span>Running the model</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../api/">Library Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Lokta-Volterra, predator-prey model</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Lokta-Volterra, predator-prey model</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/AlgebraicJulia/AlgebraicABMs.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/AlgebraicJulia/AlgebraicABMs.jl/blob/main/docs/literate/lotka_volterra.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Lokta-Volterra,-predator-prey-model"><a class="docs-heading-anchor" href="#Lokta-Volterra,-predator-prey-model">Lokta-Volterra, predator-prey model</a><a id="Lokta-Volterra,-predator-prey-model-1"></a><a class="docs-heading-anchor-permalink" href="#Lokta-Volterra,-predator-prey-model" title="Permalink"></a></h1><h2 id="Set-up"><a class="docs-heading-anchor" href="#Set-up">Set-up</a><a id="Set-up-1"></a><a class="docs-heading-anchor-permalink" href="#Set-up" title="Permalink"></a></h2><p>The first step of running a Julia program is to load the external libraries one will be using. We do this with a <code>using</code> statement.</p><pre><code class="language-julia hljs">using AlgebraicABMs, Catlab, AlgebraicRewriting, DataMigrations
using Test, Random</code></pre><p>We can also define some shorthand for some long function names</p><pre><code class="language-julia hljs">const hom = homomorphism
const homs = homomorphisms
const Var = AttrVar;</code></pre><h2 id="Schema"><a class="docs-heading-anchor" href="#Schema">Schema</a><a id="Schema-1"></a><a class="docs-heading-anchor-permalink" href="#Schema" title="Permalink"></a></h2><p>Defining a schema is stating what data is required to specify a state of the simulation at some point in time. In AlgebraicJulia, this is done via declaring a <code>Presentation</code>, i.e. a database schema. Objects (<code>Ob</code>, or tables) are types of entities. Homs (<code>Hom</code>, or foreign keys) are functional relationships between the aforementioned entities. AttrTypes are placeholders for Julia types, which are assigned to objects via attributes (<code>Attr</code>).</p><p>The schema below <em>extends</em> the schema for symmetric graphs, which consists in two tables (<code>E</code> and <code>V</code>, for edges and vertices), a hom <code>inv</code> which pairs each edge with its symmetric dual edge, and homs (<code>src</code>, <code>tgt</code>) which relate the edges to the vertices. This extension is indicated by the subtype operator <code>&lt;: SchSymmetricGraph</code>. Here we add a notion of cardinal direction to a symmetric graph, encoding that left and right are inverses and that four rotations does nothing. Edges are all assigned a cardinal direction.</p><p>These schemas don&#39;t yet have the capacity to express constraints such as &quot;each vertex has exactly four incident edges, one of each cardinal direction&quot;, but future versions of Catlab will be able to do this. For now, this is a property we will enforce when we create grids.</p><pre><code class="language-julia hljs">@present SchGrid &lt;: SchSymmetricGraph begin
  Direction::Ob
  dir::Hom(E, Direction)
  left::Hom(Direction, Direction)
  right::Hom(Direction, Direction)
  left⋅left⋅left⋅left == id(Direction)
  right⋅left == id(Direction)
  left⋅right == id(Direction)
  inv⋅dir == dir⋅left⋅left
end;

@acset_type Grid(SchGrid) &lt;: AbstractSymmetricGraph; # Create LV datatype</code></pre><p>We now want to allow wolves and sheep to live on the vertices of this grid as well as be oriented in a particular direction.</p><pre><code class="language-julia hljs">@present SchWS &lt;: SchGrid begin
  (Wolf, Sheep)::Ob
  wolf_loc::Hom(Wolf, V)
  sheep_loc::Hom(Sheep, V)
  wolf_dir::Hom(Wolf,Direction)
  sheep_dir::Hom(Sheep,Direction)
end;</code></pre><p>A set of time counters are associated with vertices via &quot;countdown&quot; which tracks how long it takes until the grass is ready to eat at a location.</p><pre><code class="language-julia hljs">@present SchWSG &lt;: SchWS begin
  Time::Ob
  countdown::Hom(Time, V)
end;</code></pre><p>The animals have an &quot;energy&quot;, drained by moving and reproduction, gained via eating food.</p><pre><code class="language-julia hljs">@present SchLV &lt;: SchWSG begin
  Eng::AttrType
  wolf_eng::Attr(Wolf, Eng)
  sheep_eng::Attr(Sheep, Eng)
end;

@acset_type LV(SchLV){Int} &lt;: AbstractSymmetricGraph # Create LV datatype

to_graphviz(SchLV; prog=&quot;dot&quot;)</code></pre><img src='data:image/svg+xml;utf-8,<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.43.0 (0)
 -->
<!-- Title: G Pages: 1 -->
<svg width="762pt" height="131pt"
 viewBox="0.00 0.00 762.00 131.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 127)">
<title>G</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-127 758,-127 758,4 -4,4"/>
<!-- n1 -->
<g id="node1" class="node">
<title>n1</title>
<ellipse fill="none" stroke="black" cx="117" cy="-18" rx="27" ry="18"/>
<text text-anchor="middle" x="117" y="-14.3" font-family="Times,serif" font-size="14.00">V</text>
</g>
<!-- n2 -->
<g id="node2" class="node">
<title>n2</title>
<ellipse fill="none" stroke="black" cx="27" cy="-105" rx="27" ry="18"/>
<text text-anchor="middle" x="27" y="-101.3" font-family="Times,serif" font-size="14.00">E</text>
</g>
<!-- n2&%2345;&gt;n1 -->
<g id="edge1" class="edge">
<title>n2&%2345;&gt;n1</title>
<path fill="none" stroke="black" d="M41.86,-89.96C56.19,-76.43 78.07,-55.77 94.53,-40.22"/>
<polygon fill="black" stroke="black" points="97.25,-42.47 102.12,-33.06 92.44,-37.38 97.25,-42.47"/>
<text text-anchor="middle" x="88" y="-57.8" font-family="Times,serif" font-size="14.00">src</text>
</g>
<!-- n2&%2345;&gt;n1 -->
<g id="edge2" class="edge">
<title>n2&%2345;&gt;n1</title>
<path fill="none" stroke="black" d="M27.83,-86.55C29.16,-76.07 32.38,-63.06 40,-54 50.78,-41.19 67.23,-32.84 82.16,-27.53"/>
<polygon fill="black" stroke="black" points="83.24,-30.86 91.68,-24.46 81.09,-24.2 83.24,-30.86"/>
<text text-anchor="middle" x="51" y="-57.8" font-family="Times,serif" font-size="14.00">tgt</text>
</g>
<!-- n2&%2345;&gt;n2 -->
<g id="edge3" class="edge">
<title>n2&%2345;&gt;n2</title>
<path fill="none" stroke="black" d="M51.53,-112.75C62.51,-113.49 72,-110.91 72,-105 72,-101.03 67.72,-98.56 61.57,-97.59"/>
<polygon fill="black" stroke="black" points="61.65,-94.09 51.53,-97.25 61.41,-101.09 61.65,-94.09"/>
<text text-anchor="middle" x="83" y="-101.3" font-family="Times,serif" font-size="14.00">inv</text>
</g>
<!-- n3 -->
<g id="node3" class="node">
<title>n3</title>
<ellipse fill="none" stroke="black" cx="344" cy="-18" rx="36.7" ry="18"/>
<text text-anchor="middle" x="344" y="-14.3" font-family="Times,serif" font-size="14.00">Direction</text>
</g>
<!-- n2&%2345;&gt;n3 -->
<g id="edge4" class="edge">
<title>n2&%2345;&gt;n3</title>
<path fill="none" stroke="black" d="M51.84,-97.67C66.62,-94.1 85.78,-89.8 103,-87 180.17,-74.44 205.26,-97.67 278,-69 293.86,-62.75 309.2,-51.55 321.09,-41.34"/>
<polygon fill="black" stroke="black" points="323.61,-43.78 328.73,-34.5 318.94,-38.56 323.61,-43.78"/>
<text text-anchor="middle" x="313.5" y="-57.8" font-family="Times,serif" font-size="14.00">dir</text>
</g>
<!-- n3&%2345;&gt;n3 -->
<g id="edge5" class="edge">
<title>n3&%2345;&gt;n3</title>
<path fill="none" stroke="black" d="M380.14,-21.93C390.68,-21.79 398.85,-20.48 398.85,-18 398.85,-16.41 395.5,-15.3 390.32,-14.68"/>
<polygon fill="black" stroke="black" points="390.32,-11.17 380.14,-14.07 389.91,-18.16 390.32,-11.17"/>
<text text-anchor="middle" x="411.35" y="-14.3" font-family="Times,serif" font-size="14.00">left</text>
</g>
<!-- n3&%2345;&gt;n3 -->
<g id="edge6" class="edge">
<title>n3&%2345;&gt;n3</title>
<path fill="none" stroke="black" d="M377.85,-25.22C400.77,-27.17 423.85,-24.77 423.85,-18 423.85,-12.24 407.11,-9.64 387.99,-10.2"/>
<polygon fill="black" stroke="black" points="387.64,-6.71 377.85,-10.78 388.04,-13.7 387.64,-6.71"/>
<text text-anchor="middle" x="441.85" y="-14.3" font-family="Times,serif" font-size="14.00">right</text>
</g>
<!-- n4 -->
<g id="node4" class="node">
<title>n4</title>
<ellipse fill="none" stroke="black" cx="344" cy="-105" rx="27" ry="18"/>
<text text-anchor="middle" x="344" y="-101.3" font-family="Times,serif" font-size="14.00">Wolf</text>
</g>
<!-- n4&%2345;&gt;n1 -->
<g id="edge7" class="edge">
<title>n4&%2345;&gt;n1</title>
<path fill="none" stroke="black" d="M318.03,-99.07C292.37,-93.65 252.38,-83.71 220,-69 208.89,-63.95 207.74,-59.8 197,-54 181.68,-45.73 164.01,-37.83 149.17,-31.64"/>
<polygon fill="black" stroke="black" points="150.47,-28.39 139.89,-27.83 147.81,-34.87 150.47,-28.39"/>
<text text-anchor="middle" x="249" y="-57.8" font-family="Times,serif" font-size="14.00">wolf_loc</text>
</g>
<!-- n4&%2345;&gt;n3 -->
<g id="edge9" class="edge">
<title>n4&%2345;&gt;n3</title>
<path fill="none" stroke="black" d="M344,-86.8C344,-75.16 344,-59.55 344,-46.24"/>
<polygon fill="black" stroke="black" points="347.5,-46.18 344,-36.18 340.5,-46.18 347.5,-46.18"/>
<text text-anchor="middle" x="373" y="-57.8" font-family="Times,serif" font-size="14.00">wolf_dir</text>
</g>
<!-- n7 -->
<g id="node7" class="node">
<title>n7</title>
<ellipse fill="black" stroke="black" cx="608" cy="-18" rx="1.8" ry="1.8"/>
<text text-anchor="middle" x="591.7" y="-23.6" font-family="Times,serif" font-size="14.00">Eng</text>
</g>
<!-- n4&%2345;&gt;n7 -->
<g id="edge12" class="edge">
<title>n4&%2345;&gt;n7</title>
<path fill="none" stroke="black" d="M370.71,-101.45C402.03,-97.65 454.86,-88.74 496,-69 505.7,-64.35 505.63,-59.29 515,-54 542.77,-38.32 578.93,-27.03 596.88,-21.97"/>
<polygon fill="black" stroke="black" points="597.88,-25.33 606.62,-19.35 596.05,-18.57 597.88,-25.33"/>
<text text-anchor="middle" x="547" y="-57.8" font-family="Times,serif" font-size="14.00">wolf_eng</text>
</g>
<!-- n5 -->
<g id="node5" class="node">
<title>n5</title>
<ellipse fill="none" stroke="black" cx="605" cy="-105" rx="27" ry="18"/>
<text text-anchor="middle" x="605" y="-101.3" font-family="Times,serif" font-size="14.00">Sheep</text>
</g>
<!-- n5&%2345;&gt;n1 -->
<g id="edge8" class="edge">
<title>n5&%2345;&gt;n1</title>
<path fill="none" stroke="black" d="M578.04,-102.84C541.24,-100.37 473.93,-92.73 422,-69 412.21,-64.53 412.93,-58.14 403,-54 380.45,-44.6 225.71,-29.16 153.71,-22.38"/>
<polygon fill="black" stroke="black" points="154,-18.89 143.71,-21.44 153.34,-25.86 154,-18.89"/>
<text text-anchor="middle" x="457" y="-57.8" font-family="Times,serif" font-size="14.00">sheep_loc</text>
</g>
<!-- n5&%2345;&gt;n3 -->
<g id="edge10" class="edge">
<title>n5&%2345;&gt;n3</title>
<path fill="none" stroke="black" d="M601.92,-86.98C598.99,-75.84 593.41,-61.93 583,-54 553.67,-31.66 451.88,-23.5 391.01,-20.58"/>
<polygon fill="black" stroke="black" points="391.02,-17.07 380.88,-20.12 390.71,-24.07 391.02,-17.07"/>
<text text-anchor="middle" x="629" y="-57.8" font-family="Times,serif" font-size="14.00">sheep_dir</text>
</g>
<!-- n5&%2345;&gt;n7 -->
<g id="edge13" class="edge">
<title>n5&%2345;&gt;n7</title>
<path fill="none" stroke="black" d="M630.32,-98.71C646.42,-93.89 666.06,-84.99 676,-69 691.27,-44.45 642.62,-28.05 619.5,-21.81"/>
<polygon fill="black" stroke="black" points="620.06,-18.34 609.51,-19.33 618.38,-25.14 620.06,-18.34"/>
<text text-anchor="middle" x="716" y="-57.8" font-family="Times,serif" font-size="14.00">sheep_eng</text>
</g>
<!-- n6 -->
<g id="node6" class="node">
<title>n6</title>
<ellipse fill="none" stroke="black" cx="139" cy="-105" rx="27" ry="18"/>
<text text-anchor="middle" x="139" y="-101.3" font-family="Times,serif" font-size="14.00">Time</text>
</g>
<!-- n6&%2345;&gt;n1 -->
<g id="edge11" class="edge">
<title>n6&%2345;&gt;n1</title>
<path fill="none" stroke="black" d="M127.29,-88.44C123.59,-82.64 119.96,-75.81 118,-69 115.91,-61.74 115.13,-53.64 115,-46.11"/>
<polygon fill="black" stroke="black" points="118.5,-46.06 115.19,-35.99 111.5,-45.92 118.5,-46.06"/>
<text text-anchor="middle" x="157.5" y="-57.8" font-family="Times,serif" font-size="14.00">countdown</text>
</g>
</g>
</svg>
'/><p>We can further extend this schema with an additional attribute of (x,y) coordinates for every vertex. This is nice for visualization but is otherwise unnecessary when doing the actual agent-based modeling. We can also add names to the directions for convenience.</p><p>So what we will do is <em>build</em> our model with the LV schema and then <em>run</em> our model with the LV_viz schema.</p><pre><code class="language-julia hljs">@present SchLV_Viz &lt;: SchLV begin
  (Coord, Name)::AttrType
  coord::Attr(V, Coord)
  dirname::Attr(Direction, Name)
end

@acset_type LV_Viz(SchLV_Viz){Int, Tuple{Int,Int}, String} &lt;: AbstractSymmetricGraph

const LV′ = Union{LV, LV_Viz};</code></pre><h2 id="Initializing-and-visualizing-world-states"><a class="docs-heading-anchor" href="#Initializing-and-visualizing-world-states">Initializing and visualizing world states</a><a id="Initializing-and-visualizing-world-states-1"></a><a class="docs-heading-anchor-permalink" href="#Initializing-and-visualizing-world-states" title="Permalink"></a></h2><p>To help us create initial states for simulations, a (hidden) helper function that makes an n × n grid with periodic boundary conditions. One edge in each cardinal direction originates at every point.</p><pre><code class="language-julia hljs">function create_grid(n::Int)::LV_Viz</code></pre><p>To initialize a state of the world with sheep and wolves, we also accept parameters which indicate the fraction of spaces that are populated with that animal.</p><pre><code class="language-julia hljs">function initialize(n::Int, sheep::Float64, wolves=nothing)::LV_Viz</code></pre><p>Some visualization code below will allow us to see states of the world. Edges are left implicit (we know from how the graphs were constructed that there are edges between every pair of adjacent vertices).</p><pre><code class="language-julia hljs">function view_LV(p::LV′, pth=tempname(); name=&quot;G&quot;, title=&quot;&quot;)</code></pre><p>We can use this to visualize an example</p><pre><code class="language-julia hljs">init = initialize(2, 0.5)
view_LV(init)</code></pre><img src='data:image/svg+xml;utf-8,<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.43.0 (0)
 -->
<!-- Title: G Pages: 1 -->
<svg width="130pt" height="121pt"
 viewBox="0.00 0.00 129.61 120.75" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 116.75)">
<title>G</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-116.75 125.61,-116.75 125.61,4 -4,4"/>
<!-- v1 -->
<g id="node1" class="node">
<title>v1</title>
<ellipse fill="tan" stroke="tan" cx="18" cy="-22.75" rx="18" ry="18"/>
<text text-anchor="middle" x="18" y="-19.05" font-family="Times,serif" font-size="14.00">1</text>
</g>
<!-- v2 -->
<g id="node2" class="node">
<title>v2</title>
<ellipse fill="tan" stroke="tan" cx="18" cy="-94.75" rx="18" ry="18"/>
<text text-anchor="middle" x="18" y="-91.05" font-family="Times,serif" font-size="14.00">5</text>
</g>
<!-- v3 -->
<g id="node3" class="node">
<title>v3</title>
<ellipse fill="tan" stroke="tan" cx="90" cy="-22.75" rx="23" ry="23"/>
<text text-anchor="middle" x="90" y="-19.05" font-family="Times,serif" font-size="14.00">24</text>
</g>
<!-- v4 -->
<g id="node4" class="node">
<title>v4</title>
<ellipse fill="lightgreen" stroke="lightgreen" cx="90" cy="-94.75" rx="18" ry="18"/>
</g>
<!-- w1 -->
<g id="node5" class="node">
<title>w1</title>
<polygon fill="red" stroke="red" points="83.29,-37.1 61.29,-37.1 61.29,-15.1 83.29,-15.1 83.29,-37.1"/>
<text text-anchor="middle" x="72.29" y="-22.4" font-family="Times,serif" font-size="14.00">1⁵</text>
</g>
<!-- w2 -->
<g id="node6" class="node">
<title>w2</title>
<polygon fill="red" stroke="red" points="121.61,-34.48 99.61,-34.48 99.61,-12.48 121.61,-12.48 121.61,-34.48"/>
<text text-anchor="middle" x="110.61" y="-19.78" font-family="Times,serif" font-size="14.00">2⁵</text>
</g>
<!-- s1 -->
<g id="node7" class="node">
<title>s1</title>
<polygon fill="lightblue" stroke="lightblue" points="88.18,-37.88 66.18,-37.88 66.18,-15.88 88.18,-15.88 88.18,-37.88"/>
<text text-anchor="middle" x="77.18" y="-23.18" font-family="Times,serif" font-size="14.00">1⁵</text>
</g>
<!-- s2 -->
<g id="node8" class="node">
<title>s2</title>
<polygon fill="lightblue" stroke="lightblue" points="51.78,-35.87 29.78,-35.87 29.78,-13.87 51.78,-13.87 51.78,-35.87"/>
<text text-anchor="middle" x="40.78" y="-21.17" font-family="Times,serif" font-size="14.00">2⁵</text>
</g>
</g>
</svg>
'/><h1 id="Data-migration-functors"><a class="docs-heading-anchor" href="#Data-migration-functors">Data migration functors</a><a id="Data-migration-functors-1"></a><a class="docs-heading-anchor-permalink" href="#Data-migration-functors" title="Permalink"></a></h1><p>The schema LV has a certain symmetry between wolves and sheep, and this symmetry can be used to take <em>instances</em> of the schema (i.e. world states) and swap the wolves and the sheep. This is helpful for avoiding repeating work: there are certain actions that wolves and sheep share, so, by using this data migration, we can define them in terms of sheep and then migrate along <code>F</code> to obtain the analogous actions for wolves.</p><pre><code class="language-julia hljs">F = Migrate(
  Dict(:Sheep =&gt; :Wolf, :Wolf =&gt; :Sheep),
  Dict([:sheep_loc =&gt; :wolf_loc, :wolf_loc =&gt; :sheep_loc,
    :sheep_eng =&gt; :wolf_eng, :wolf_eng =&gt; :sheep_eng, :countdown =&gt; :countdown,
    :sheep_dir =&gt; :wolf_dir, :wolf_dir =&gt; :sheep_dir,]), SchLV, LV);</code></pre><p>We ought to be able to take a state of the world (with no coordinate information) and obtain a state of the world with coordinates (the canonical way to do this is to assign &quot;variables&quot; for the values of the coordinates).</p><pre><code class="language-julia hljs">Viz = Migrate(SchLV, LV, SchLV_Viz, LV_Viz; delta=false);</code></pre><h1 id="Representables"><a class="docs-heading-anchor" href="#Representables">Representables</a><a id="Representables-1"></a><a class="docs-heading-anchor-permalink" href="#Representables" title="Permalink"></a></h1><p>We want to say &quot;give me a sheep&quot; or &quot;give me a sheep and a wolf that are on the same vertex&quot; and have it automatically specify the remaining information in the most generic way possible. The <code>@acset_colim</code> macro is perfect for exactly this. In order to use that macro, we need to precompute the <code>yoneda_cache</code>.</p><pre><code class="language-julia hljs">yLV = yoneda_cache(LV);
I = LV() # Empty agent type
S = @acset_colim yLV begin s::Sheep end # Generic sheep agent
E = @acset_colim yLV begin e::E end # Generic edge
Eng = @acset_colim yLV begin e::Eng end # Free floating energy unit
D = @acset_colim yLV begin D::Direction end # Generic cardinal directions
W = F(S) # Generic wolf agent, obtained via the swapping `F` data migration
G = @acset_colim yLV begin v::V end; # Generic grass agent (i.e. vertex)</code></pre><h1 id="Rules"><a class="docs-heading-anchor" href="#Rules">Rules</a><a id="Rules-1"></a><a class="docs-heading-anchor-permalink" href="#Rules" title="Permalink"></a></h1><p>We have finished specifying what makes up a simulation state, and next is to define what sorts of transitions are possible. This is done by declaring rewrite rules.</p><h3 id="Rotating"><a class="docs-heading-anchor" href="#Rotating">Rotating</a><a id="Rotating-1"></a><a class="docs-heading-anchor-permalink" href="#Rotating" title="Permalink"></a></h3><p>Our first action that is possible for sheep (and wolves) is rotation. Animals will, with some probability, change their orientation. This is a rewrite rule which only modifies an attribute rather than changing any combinatorial data, so rather than the usual span <code>L ← I → R</code> data required we simply put in a single ACSet along with an <code>expr</code> dictionary which states how attributes change.</p><pre><code class="language-julia hljs">DVS_N, DVS_E, DVS_W, _ = homs(D ⊕ G ⊕ Eng, S; initial=(Eng=[Var(1)],))
sheep_rl = Rule(DVS_N, DVS_E);
sheep_rr = Rule(DVS_N, DVS_W);</code></pre><h4 id="Test-rotation"><a class="docs-heading-anchor" href="#Test-rotation">Test rotation</a><a id="Test-rotation-1"></a><a class="docs-heading-anchor-permalink" href="#Test-rotation" title="Permalink"></a></h4><pre><code class="language-julia hljs">ex = @acset_colim yLV begin
  e::E; s::Sheep;
  sheep_loc(s)==src(e); sheep_eng(s)==100; dir(e)==left(sheep_dir(s))
end;

expected = copy(ex);
expected[:sheep_dir] = ex[1, :dir] # rotate right aligns the sheep w/ the edge

@test is_isomorphic(rewrite(sheep_rl, ex), expected)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr32"><span class="sgr1">Test Passed</span></span></code></pre><h3 id="Moving-forward"><a class="docs-heading-anchor" href="#Moving-forward">Moving forward</a><a id="Moving-forward-1"></a><a class="docs-heading-anchor-permalink" href="#Moving-forward" title="Permalink"></a></h3><pre><code class="language-julia hljs">s_fwd_l = @acset_colim yLV begin
  e::E; s::Sheep
  sheep_loc(s) == src(e)
  dir(e) == sheep_dir(s)
end

s_fwd_r = @acset_colim yLV begin
  e::E; s::Sheep; sheep_loc(s) == tgt(e); dir(e) == sheep_dir(s)
end;

sheep_fwd_rule = Rule(first(homs(E, s_fwd_l; monic=true)),
                      last(homs(E,  s_fwd_r; monic=true)),
                      expr=(Eng=[((eₛ,),) -&gt; eₛ - 1],));</code></pre><h4 id="Moving-forward-test"><a class="docs-heading-anchor" href="#Moving-forward-test">Moving forward test</a><a id="Moving-forward-test-1"></a><a class="docs-heading-anchor-permalink" href="#Moving-forward-test" title="Permalink"></a></h4><pre><code class="language-julia hljs">ex = @acset_colim yLV begin
  (e1,e2)::E; (s::Sheep)
  src(e2)==tgt(e1); sheep_loc(s)==src(e1)
  sheep_eng(s)==10
  sheep_dir(s)==dir(e1); dir(e1)==left(dir(e2))
end
expected = copy(ex);
expected[1, :sheep_loc] = ex[1, :tgt]
expected[1, :sheep_eng] = 9

@test is_isomorphic(expected, rewrite(sheep_fwd_rule, ex))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr32"><span class="sgr1">Test Passed</span></span></code></pre><h3 id="Sheep-eat-grass"><a class="docs-heading-anchor" href="#Sheep-eat-grass">Sheep eat grass</a><a id="Sheep-eat-grass-1"></a><a class="docs-heading-anchor-permalink" href="#Sheep-eat-grass" title="Permalink"></a></h3><pre><code class="language-julia hljs">s_eat_N = @acset_colim yLV begin
  s::Sheep; t::Time; countdown(t) == sheep_loc(s)
end
s_eat_L = @acset_colim yLV begin s::Sheep;  end;
s_eat_R = deepcopy(s_eat_L)
add_parts!(s_eat_R, :Time, 30; countdown=1)
se_left = hom(G⊕D, s_eat_L; initial=(Direction=1:4,))
se_right = hom(G⊕D, s_eat_R;  initial=(Direction=1:4,))
se_nac = hom(s_eat_L, s_eat_N)
se_rule = Rule(se_left, se_right;
               ac=[AppCond(se_nac, false)], expr=(Eng=[((vₛ,),) -&gt; vₛ + 4],));</code></pre><h4 id="Sheep-eating-test"><a class="docs-heading-anchor" href="#Sheep-eating-test">Sheep eating test</a><a id="Sheep-eating-test-1"></a><a class="docs-heading-anchor-permalink" href="#Sheep-eating-test" title="Permalink"></a></h4><pre><code class="language-julia hljs">ex = @acset_colim yLV begin
  e::E; s::Sheep; t::Time
  dir(e)==sheep_dir(s); countdown(t)==src(e);
  sheep_loc(s)==tgt(e); sheep_eng(s) == 3
end

expected = copy(ex)
add_parts!(expected, :Time, 30; countdown=2)
expected[1,:sheep_eng] = 7
@test is_isomorphic(expected, rewrite(se_rule, ex))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr32"><span class="sgr1">Test Passed</span></span></code></pre><h3 id="Wolves-eat-sheep"><a class="docs-heading-anchor" href="#Wolves-eat-sheep">Wolves eat sheep</a><a id="Wolves-eat-sheep-1"></a><a class="docs-heading-anchor-permalink" href="#Wolves-eat-sheep" title="Permalink"></a></h3><pre><code class="language-julia hljs">w_eat_l = @acset_colim yLV begin
  s::Sheep; w::Wolf; sheep_loc(s) == wolf_loc(w)
end;

we_left = hom(G⊕D⊕D, w_eat_l; initial=(Direction=Dict(1=&gt;1, 5=&gt;5),))
we_right = hom(G⊕D⊕D, D⊕W; initial=(Direction=Dict(1=&gt;1, 5=&gt;5),))
we_rule = Rule(we_left, we_right;
               expr=(Eng=[((vₛ, vᵩ),) -&gt; vᵩ + 20],));</code></pre><h4 id="Wolf-eating-test"><a class="docs-heading-anchor" href="#Wolf-eating-test">Wolf eating test</a><a id="Wolf-eating-test-1"></a><a class="docs-heading-anchor-permalink" href="#Wolf-eating-test" title="Permalink"></a></h4><pre><code class="language-julia hljs">ex = @acset_colim yLV begin
  (s::Sheep); (w::Wolf); (e::E); (t1,t2,t3)::Time
  countdown(t1)==src(e); countdown(t2)==src(e); countdown(t3)==tgt(e)
  sheep_dir(s)==left(wolf_dir(w))
  sheep_dir(s)==right(dir(e))
  sheep_eng(s)==3; wolf_eng(w)==16
  sheep_loc(s)==tgt(e); wolf_loc(w)==tgt(e)
end

expected = copy(ex)
expected[1, :wolf_eng] = 36
rem_part!(expected, :Sheep, 1)

@test is_isomorphic(rewrite(we_rule, ex), expected)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr32"><span class="sgr1">Test Passed</span></span></code></pre><h3 id="Sheep-starvation"><a class="docs-heading-anchor" href="#Sheep-starvation">Sheep starvation</a><a id="Sheep-starvation-1"></a><a class="docs-heading-anchor-permalink" href="#Sheep-starvation" title="Permalink"></a></h3><pre><code class="language-julia hljs">s_die_l = @acset_colim yLV begin s::Sheep; sheep_eng(s) == 0 end;
sheep_die_rule = Rule(hom(G⊕D, s_die_l; any=true), id(G⊕D));</code></pre><h4 id="Sheep-starvation-test"><a class="docs-heading-anchor" href="#Sheep-starvation-test">Sheep starvation test</a><a id="Sheep-starvation-test-1"></a><a class="docs-heading-anchor-permalink" href="#Sheep-starvation-test" title="Permalink"></a></h4><pre><code class="language-julia hljs">ex = @acset_colim yLV begin
  s::Sheep; w::Wolf; (t,t2)::Time
  countdown(t)==sheep_loc(s); countdown(t2)==wolf_loc(w)
  sheep_eng(s)==0; wolf_eng(w)==10; sheep_dir(s) == right(wolf_dir(w))
end
expected = copy(ex)
rem_part!(expected, :Sheep, 1)

@test is_isomorphic(rewrite(sheep_die_rule,ex), expected)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr32"><span class="sgr1">Test Passed</span></span></code></pre><h3 id="Reproduction"><a class="docs-heading-anchor" href="#Reproduction">Reproduction</a><a id="Reproduction-1"></a><a class="docs-heading-anchor-permalink" href="#Reproduction" title="Permalink"></a></h3><pre><code class="language-julia hljs">s_reprod_r = @acset_colim yLV begin
  (x, y)::Sheep; sheep_loc(x) == sheep_loc(y); sheep_dir(x)==sheep_dir(y)
end;

sheep_reprod_rule = Rule(
  hom(G⊕D, S; any=true),
  hom(G⊕D, s_reprod_r; any=true);
  expr=(Dir=fill(vs-&gt;only(vs) ,2),
        Eng=fill(vs -&gt; round(Int, vs[1] / 2, RoundUp), 2),)
);</code></pre><h4 id="Reproduction-test"><a class="docs-heading-anchor" href="#Reproduction-test">Reproduction test</a><a id="Reproduction-test-1"></a><a class="docs-heading-anchor-permalink" href="#Reproduction-test" title="Permalink"></a></h4><pre><code class="language-julia hljs">ex = @acset_colim yLV begin
  s::Sheep; w::Wolf; t::Time
  countdown(t)==sheep_loc(s);
  sheep_eng(s)==10; wolf_eng(w)==20; sheep_dir(s) == right(wolf_dir(w))
end

expected = copy(ex)
add_part!(expected,:Sheep)
expected[:sheep_eng] = [5, 5]
expected[:sheep_loc] = fill(ex[1,:sheep_loc], 2)
expected[:sheep_dir] = fill(ex[1,:sheep_dir], 2)

m = hom(pattern(sheep_reprod_rule),ex)
can_match(sheep_reprod_rule, m)
@test is_isomorphic(rewrite(sheep_reprod_rule,ex),expected)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr32"><span class="sgr1">Test Passed</span></span></code></pre><h3 id="Grass-increments"><a class="docs-heading-anchor" href="#Grass-increments">Grass increments</a><a id="Grass-increments-1"></a><a class="docs-heading-anchor-permalink" href="#Grass-increments" title="Permalink"></a></h3><pre><code class="language-julia hljs">g_inc_L = @acset_colim yLV begin t::Time end
rem_time = hom(G, g_inc_L)
g_inc_rule = Rule(rem_time, id(G));</code></pre><h4 id="Grass-incrementing-test"><a class="docs-heading-anchor" href="#Grass-incrementing-test">Grass incrementing test</a><a id="Grass-incrementing-test-1"></a><a class="docs-heading-anchor-permalink" href="#Grass-incrementing-test" title="Permalink"></a></h4><pre><code class="language-julia hljs">ex = @acset_colim yLV begin
  e::E; t::Time; countdown(t) == tgt(e)
end

@test is_isomorphic(rewrite(g_inc_rule, ex), E)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr32"><span class="sgr1">Test Passed</span></span></code></pre><h1 id="Adding-timers-to-the-rules-and-making-the-model"><a class="docs-heading-anchor" href="#Adding-timers-to-the-rules-and-making-the-model">Adding timers to the rules and making the model</a><a id="Adding-timers-to-the-rules-and-making-the-model-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-timers-to-the-rules-and-making-the-model" title="Permalink"></a></h1><p>With our possible actions defined, we now need to provide enough information for a simulator to execute the actions in time. A simple way of doing this is to add an exponential waiting time to each action.</p><pre><code class="language-julia hljs">MkRule(args) = ABMRule(args[1], args[2], ContinuousHazard(args[3]))

rules = MkRule.([
  (:SheepRotateRight, sheep_rr , 1.),
  (:SheepRotateLeft, sheep_rl , 1.),
  (:SheepMoveFwd, sheep_fwd_rule, 0.5),
  (:WolfRotateRight, F(sheep_rr), 1.),
  (:WolfRotateLeft, F(sheep_rl),1.),
  (:WolfMoveFwd, F(sheep_fwd_rule), .25),
  (:SheepStarve, sheep_die_rule, 0.001),
  (:WolfStarve, F(sheep_die_rule), 0.001),
  (:SheepReprod, sheep_reprod_rule, 0.5),
  (:WolfReprod, F(sheep_reprod_rule), 20),
  (:GrassGrow, g_inc_rule , 1.)])


abm = ABM(rules) # this is defined for SchLV, not SchLV_Viz
abm_viz = Viz(abm);</code></pre><h1 id="Running-the-model"><a class="docs-heading-anchor" href="#Running-the-model">Running the model</a><a id="Running-the-model-1"></a><a class="docs-heading-anchor-permalink" href="#Running-the-model" title="Permalink"></a></h1><pre><code class="language-julia hljs">init = initialize(2, 0.25)

res = run!(abm_viz, init; maxevent=3)
imgs = view(res, view_LV);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ Debug: Step 0: Event GrassGrow | Fired @ t = 0.0 (8 queued)
└ @ AlgebraicABMs.ABMs ~/work/AlgebraicABMs.jl/AlgebraicABMs.jl/src/ABMs.jl:485
┌ Debug: Step 1: Event GrassGrow | Fired @ t = 0.03 (9 queued)
└ @ AlgebraicABMs.ABMs ~/work/AlgebraicABMs.jl/AlgebraicABMs.jl/src/ABMs.jl:485
┌ Debug: Step 2: Event GrassGrow | Fired @ t = 0.03 (10 queued)
└ @ AlgebraicABMs.ABMs ~/work/AlgebraicABMs.jl/AlgebraicABMs.jl/src/ABMs.jl:485</code></pre><p>The first image is our starting point.</p><pre><code class="language-julia hljs">imgs[1]</code></pre><img src='data:image/svg+xml;utf-8,<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.43.0 (0)
 -->
<!-- Title: G Pages: 1 -->
<svg width="270pt" height="156pt"
 viewBox="0.00 0.00 270.00 155.62" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 151.62)">
<title>G</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-151.62 266,-151.62 266,4 -4,4"/>
<text text-anchor="middle" x="131" y="-132.42" font-family="Times,serif" font-size="14.00">Step 0 @ t=0: Event (Initial state)</text>
<!-- v1 -->
<g id="node1" class="node">
<title>v1</title>
<ellipse fill="lightgreen" stroke="lightgreen" cx="97.8" cy="-22.75" rx="18" ry="18"/>
</g>
<!-- v2 -->
<g id="node2" class="node">
<title>v2</title>
<ellipse fill="tan" stroke="tan" cx="97.8" cy="-94.75" rx="23" ry="23"/>
<text text-anchor="middle" x="97.8" y="-91.05" font-family="Times,serif" font-size="14.00">29</text>
</g>
<!-- v3 -->
<g id="node3" class="node">
<title>v3</title>
<ellipse fill="tan" stroke="tan" cx="169.8" cy="-22.75" rx="23" ry="23"/>
<text text-anchor="middle" x="169.8" y="-19.05" font-family="Times,serif" font-size="14.00">23</text>
</g>
<!-- v4 -->
<g id="node4" class="node">
<title>v4</title>
<ellipse fill="lightgreen" stroke="lightgreen" cx="169.8" cy="-94.75" rx="18" ry="18"/>
</g>
<!-- w1 -->
<g id="node5" class="node">
<title>w1</title>
<polygon fill="red" stroke="red" points="91.45,-37.94 69.45,-37.94 69.45,-15.94 91.45,-15.94 91.45,-37.94"/>
<text text-anchor="middle" x="80.45" y="-23.24" font-family="Times,serif" font-size="14.00">1⁵</text>
</g>
<!-- s1 -->
<g id="node6" class="node">
<title>s1</title>
<polygon fill="lightblue" stroke="lightblue" points="111.04,-124.62 89.04,-124.62 89.04,-102.62 111.04,-102.62 111.04,-124.62"/>
<text text-anchor="middle" x="100.04" y="-109.92" font-family="Times,serif" font-size="14.00">1⁵</text>
</g>
</g>
</svg>
'/><p>Then the first event</p><pre><code class="language-julia hljs">imgs[2]</code></pre><img src='data:image/svg+xml;utf-8,<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.43.0 (0)
 -->
<!-- Title: G Pages: 1 -->
<svg width="432pt" height="155pt"
 viewBox="0.00 0.00 432.00 155.27" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 151.27)">
<title>G</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-151.27 428,-151.27 428,4 -4,4"/>
<text text-anchor="middle" x="212" y="-132.07" font-family="Times,serif" font-size="14.00">Step 1 @ t=0.0002454237623378135: Event GrassGrow</text>
<!-- v1 -->
<g id="node1" class="node">
<title>v1</title>
<ellipse fill="tan" stroke="tan" cx="178.39" cy="-94.75" rx="23" ry="23"/>
<text text-anchor="middle" x="178.39" y="-91.05" font-family="Times,serif" font-size="14.00">28</text>
</g>
<!-- v2 -->
<g id="node2" class="node">
<title>v2</title>
<ellipse fill="lightgreen" stroke="lightgreen" cx="178.39" cy="-22.75" rx="18" ry="18"/>
</g>
<!-- v3 -->
<g id="node3" class="node">
<title>v3</title>
<ellipse fill="tan" stroke="tan" cx="250.39" cy="-22.75" rx="23" ry="23"/>
<text text-anchor="middle" x="250.39" y="-19.05" font-family="Times,serif" font-size="14.00">23</text>
</g>
<!-- v4 -->
<g id="node4" class="node">
<title>v4</title>
<ellipse fill="lightgreen" stroke="lightgreen" cx="250.39" cy="-94.75" rx="18" ry="18"/>
</g>
<!-- w1 -->
<g id="node5" class="node">
<title>w1</title>
<polygon fill="red" stroke="red" points="172.86,-36.53 150.86,-36.53 150.86,-14.53 172.86,-14.53 172.86,-36.53"/>
<text text-anchor="middle" x="161.86" y="-21.83" font-family="Times,serif" font-size="14.00">1⁵</text>
</g>
<!-- s1 -->
<g id="node6" class="node">
<title>s1</title>
<polygon fill="lightblue" stroke="lightblue" points="189.52,-124.27 167.52,-124.27 167.52,-102.27 189.52,-102.27 189.52,-124.27"/>
<text text-anchor="middle" x="178.52" y="-109.57" font-family="Times,serif" font-size="14.00">1⁵</text>
</g>
</g>
</svg>
'/><p>Then the second event</p><pre><code class="language-julia hljs">imgs[3]</code></pre><img src='data:image/svg+xml;utf-8,<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.43.0 (0)
 -->
<!-- Title: G Pages: 1 -->
<svg width="423pt" height="157pt"
 viewBox="0.00 0.00 423.00 157.47" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 153.47)">
<title>G</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-153.47 419,-153.47 419,4 -4,4"/>
<text text-anchor="middle" x="207.5" y="-134.27" font-family="Times,serif" font-size="14.00">Step 2 @ t=0.025563505757381425: Event GrassGrow</text>
<!-- v1 -->
<g id="node1" class="node">
<title>v1</title>
<ellipse fill="tan" stroke="tan" cx="243.5" cy="-22.75" rx="23" ry="23"/>
<text text-anchor="middle" x="243.5" y="-19.05" font-family="Times,serif" font-size="14.00">22</text>
</g>
<!-- v2 -->
<g id="node2" class="node">
<title>v2</title>
<ellipse fill="tan" stroke="tan" cx="171.5" cy="-94.75" rx="23" ry="23"/>
<text text-anchor="middle" x="171.5" y="-91.05" font-family="Times,serif" font-size="14.00">28</text>
</g>
<!-- v3 -->
<g id="node3" class="node">
<title>v3</title>
<ellipse fill="lightgreen" stroke="lightgreen" cx="171.5" cy="-22.75" rx="18" ry="18"/>
</g>
<!-- v4 -->
<g id="node4" class="node">
<title>v4</title>
<ellipse fill="lightgreen" stroke="lightgreen" cx="243.5" cy="-94.75" rx="18" ry="18"/>
</g>
<!-- w1 -->
<g id="node5" class="node">
<title>w1</title>
<polygon fill="red" stroke="red" points="171.08,-36.54 149.08,-36.54 149.08,-14.54 171.08,-14.54 171.08,-36.54"/>
<text text-anchor="middle" x="160.08" y="-21.84" font-family="Times,serif" font-size="14.00">1⁵</text>
</g>
<!-- s1 -->
<g id="node6" class="node">
<title>s1</title>
<polygon fill="lightblue" stroke="lightblue" points="188.06,-126.47 166.06,-126.47 166.06,-104.47 188.06,-104.47 188.06,-126.47"/>
<text text-anchor="middle" x="177.06" y="-111.77" font-family="Times,serif" font-size="14.00">1⁵</text>
</g>
</g>
</svg>
'/><p>And the third event</p><pre><code class="language-julia hljs">imgs[4]</code></pre><img src='data:image/svg+xml;utf-8,<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.43.0 (0)
 -->
<!-- Title: G Pages: 1 -->
<svg width="423pt" height="161pt"
 viewBox="0.00 0.00 423.00 160.97" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 156.97)">
<title>G</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-156.97 419,-156.97 419,4 -4,4"/>
<text text-anchor="middle" x="207.5" y="-137.77" font-family="Times,serif" font-size="14.00">Step 3 @ t=0.026824365867984853: Event GrassGrow</text>
<!-- v1 -->
<g id="node1" class="node">
<title>v1</title>
<ellipse fill="tan" stroke="tan" cx="171.5" cy="-94.75" rx="23" ry="23"/>
<text text-anchor="middle" x="171.5" y="-91.05" font-family="Times,serif" font-size="14.00">27</text>
</g>
<!-- v2 -->
<g id="node2" class="node">
<title>v2</title>
<ellipse fill="tan" stroke="tan" cx="243.5" cy="-22.75" rx="23" ry="23"/>
<text text-anchor="middle" x="243.5" y="-19.05" font-family="Times,serif" font-size="14.00">22</text>
</g>
<!-- v3 -->
<g id="node3" class="node">
<title>v3</title>
<ellipse fill="lightgreen" stroke="lightgreen" cx="171.5" cy="-22.75" rx="18" ry="18"/>
</g>
<!-- v4 -->
<g id="node4" class="node">
<title>v4</title>
<ellipse fill="lightgreen" stroke="lightgreen" cx="243.5" cy="-94.75" rx="18" ry="18"/>
</g>
<!-- w1 -->
<g id="node5" class="node">
<title>w1</title>
<polygon fill="red" stroke="red" points="170.8,-35.65 148.8,-35.65 148.8,-13.65 170.8,-13.65 170.8,-35.65"/>
<text text-anchor="middle" x="159.8" y="-20.95" font-family="Times,serif" font-size="14.00">1⁵</text>
</g>
<!-- s1 -->
<g id="node6" class="node">
<title>s1</title>
<polygon fill="lightblue" stroke="lightblue" points="188.99,-129.97 166.99,-129.97 166.99,-107.97 188.99,-107.97 188.99,-129.97"/>
<text text-anchor="middle" x="177.99" y="-115.27" font-family="Times,serif" font-size="14.00">1⁵</text>
</g>
</g>
</svg>
'/><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../game_of_life/">« Conway&#39;s Game of Life</a><a class="docs-footer-nextpage" href="../../api/">Library Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Saturday 20 July 2024 03:51">Saturday 20 July 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
