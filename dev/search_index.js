var documenterSearchIndex = {"docs":
[{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"EditURL = \"../../literate/game_of_life.jl\"","category":"page"},{"location":"generated/game_of_life/#Conway's-Game-of-Life","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"","category":"section"},{"location":"generated/game_of_life/#Set-up","page":"Conway's Game of Life","title":"Set-up","text":"","category":"section"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"The first step of running a Julia program is to load the external libraries one will be using. We do this with a using statement.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"using AlgebraicABMs, Catlab, AlgebraicRewriting, Random, Test\nENV[\"JULIA_DEBUG\"] = \"AlgebraicABMs\"; # hide\nRandom.seed!(100)","category":"page"},{"location":"generated/game_of_life/#Schema","page":"Conway's Game of Life","title":"Schema","text":"","category":"section"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"Defining an schema is stating what data is required to specify a state of the simulation at some point in time. In AlgebraicJulia, this is done via declaring a Presentation, i.e. a database schema. Objects (Ob, or tables) are types of entities. Homs (Hom, or foreign keys) are functional relationships between the aforementioned entities. AttrTypes are placeholders for Julia types, which are assigned to objects via attributes (Attr).","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"The schema below extends the schema for symmetric graphs, which consists in two tables (E and V, for edges and vertices), a hom inv which pairs each edge with its symmetric dual edge, and homs (src, tgt) which relate the edges to the vertices. We consider each vertex to be a cell in the Game of Life. This is a generalization of the game, since it is not enforced that every cell has eight neighbors. However the example we run at the end will be a regular grid of vertices.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"Everything in the @present presentation below simply adds to the schema of symmetric graphs, indicated by the subtype operator <: SchSymmetricGraph. We need one more piece of information to specify a state of the world in the game of life: which cells are alive? There are a few ways one could distinguish the living cells from the dead ones. Here, we add a new table, Life which can be though of as a set of \"life tokens\". A function, live, assigns each such token to a cell, designating it to be alive. Thus the subset of living cells is the image of the live function.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"To summarize, a state of the world in the Game of Life is a set of cells (i.e. vertices), a set of edges (with src/tgt functions) which encode which cells are near each other, and a distinguished subset of cells given by the live function which marks which cells are alive. This information is summarized in the following graphical depiction of the schema.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"@present SchLifeGraph <: SchSymmetricGraph begin\n  Life::Ob\n  live::Hom(Life,V)\nend\n\nto_graphviz(SchLifeGraph) # visualize the schema","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"If SchLifeGraph is the piece of data which describes what it means to be a world state, we need a Julia datatype whose values are world staets.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"The @acset_type macro takes the specification of a datatype (i.e. a schema), and it generates an efficient Julia datatype, which is essentially the type of in-memory databases which have their schema given by SchLifeGraph.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"This line defines LifeState to be this new Julia type, and futhermore it states that it satisfies the AbstractSymmetricGraph interface: Catlab already has a lot of generic code to work with SymmetricGraph-like things, so now we are free to use it with LifeState.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"@acset_type LifeState(SchLifeGraph) <: AbstractSymmetricGraph;\nnothing #hide","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"Before we start defining the dynamics of our Game of Life, it'll be helpful to visualize states of the world. One thing that SchLifeGraph did not have was (x,y) coordinate information. Because we were representing proximity of vertices by the prescence or absence of an edge connecting them, these coordinates are irrelevant to the model dynamics.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"However, the coordinates are useful for visualization, so the below code creates a new schema which extends the previous one to add coordinates.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"@present SchLifeCoords <: SchLifeGraph begin\n  Coords::AttrType\n  coords::Attr(V, Coords)\nend\n\nto_graphviz(SchLifeCoords)","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"Likewise for this new schema, we need to use @acset_type to turn the description of the required data of a world state (the schema) into an actual Julia datatype. One difference here is that there is now an attribute present, which means we need to indicate what Julia type it should be.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"Our new Julia type is LifeStateCoords, and we pick Tuple{Int,Int} as our representation of (x,y) coordinates.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"@acset_type LifeStateCoords(SchLifeCoords){Tuple{Int,Int}} <: AbstractSymmetricGraph;\nnothing #hide","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"The following (hidden) code visualizes LifeStates and uses coordinates if the input is a LifeStateCoords, but otherwise it places the vertices in an arbitrary location.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"function view_life(X::Union{LifeState, LifeStateCoords}, pth=tempname())\n  pg = PropertyGraph{Any}(; prog=\"neato\", graph=Dict(), # hide\n    node=Dict(:shape => \"circle\", :style => \"filled\", :margin => \"0\"), # hide\n    edge=Dict(:dir => \"none\", :minlen => \"1\")) # hide\n  add_vertices!(pg, nparts(X, :V)) # hide\n  for v in vertices(X) # hide\n    is_alive = isempty(incident(X, v, :live)) # hide\n    set_vprop!(pg, v, :fillcolor, is_alive ? \"red\" : \"green\") # hide\n    if X isa LifeStateCoords # hide\n      x, y = X[v, :coords] # hide\n      set_vprop!(pg, v, :pos, \"$x,$(y)!\") # hide\n    end # hide\n  end # hide\n  for e in filter(e -> X[e, :inv] > e, edges(X)) # hide\n    add_edge!(pg, X[e, :src], X[e, :tgt]) # hide\n  end # hide\n  G = to_graphviz(pg) # hide\n  open(pth, \"w\") do io # hide\n    show(io, \"image/svg+xml\", G) # hide\n  end # hide\n  return G # hide\nend; # hide\nnothing #hide","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"This (hidden) helper function creates an ordinary, square grid and initializes cells as alive or dead via a boolean-valued input matrix. Like above, one does not need to understand this in order to understand the Game of Life model - it's just a convenient way to generate some initial states to run the model on.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"function make_grid(curr::AbstractMatrix)\n  n, m = size(curr) # hide\n  n == m || error(\"Must be square\") # hide\n  X, coords = LifeStateCoords(), Dict() # hide\n  for j in 1:n, i in 1:n # hide\n    coords[i=>j] = add_vertex!(X; coords=(i, j)) # hide\n    Bool(curr[i, j]) && add_part!(X, :Life, live=coords[i=>j]) # hide\n  end # hide\n  for i in 1:n, j in 1:n # hide\n    i < n && add_edge!(X, coords[i=>j], coords[i+1=>j]) # hide\n    j < n && add_edge!(X, coords[i=>j], coords[i=>j+1]) # hide\n    i < n && j < n && add_edge!(X, coords[i=>j], coords[i+1=>j+1]) # hide\n    i < n && j > 1 && add_edge!(X, coords[i=>j], coords[i+1=>j-1]) # hide\n  end # hide\n  return X # hide\nend; # hide\nnothing #hide","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"Another helper function, which creates a game state on a square n × n grid. If the keyword random is true (which it is, by default), then cells have a 50% chance of being alive.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"Note: red color means that a cell is not in the image of the live function.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"make_grid(n::Int, random=true) =\n  make_grid((random ? rand : zeros)(Bool, (n, n)));\n\nview_life(make_grid(3)) # For example, visualize a random 3x3 grid","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"We've now constructed two schemas and two datatypes. No doubt they are related to each other, and AlgebraicJulia gives us the ability to take advantage of that relationship in order to automatically values of LifeStateCoords into values of LifeState (it does this is the obvious way: it throws away the coordinate information). More interestingly, it gives us a way of converting a LifeState into a LifeStateCoords: we give \"generic\" coordinates to each of the vertices.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"If we call AddCoords on something built out of LifeState instances, it will make the corresponding thing built out of LifeStateCoords instances.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"AddCoords = Migrate(SchLifeGraph, LifeState, SchLifeCoords, LifeStateCoords; delta=false);\nnothing #hide","category":"page"},{"location":"generated/game_of_life/#Initial-state-for-the-model","page":"Conway's Game of Life","title":"Initial state for the model","text":"","category":"section"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"With our make_grid function, it's easy to create an initial state.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"G = make_grid([0 1 0;\n               1 1 1;\n               0 1 0])\nview_life(G)","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"We'll use this world-state, called G throughout the model-building process to confirm our model building blocks work the way they're supposed to work.","category":"page"},{"location":"generated/game_of_life/#Building-blocks-for-the-Game-of-Life-model","page":"Conway's Game of Life","title":"Building blocks for the Game of Life model","text":"","category":"section"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"We are now ready to build our model, which will have three rules: underpopulation, overpopulation, and birth. When we write these rules down, it will be very succinct due to the hard work of this section: laying out the building blocks.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"Our first building block is an instance of LifeState. Now, we don't want to think of this as a particular state of the game of life, but rather we want to think of it as a pattern for which we could look for matches inside a real game state.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"This pattern is very simple: it consists of a single vertex. A match for this pattern in some world state X is just a choice of a vertex in X. The matched vertex need not be dead just because our pattern vertex is not marked as alive. So the meaning of Cell is \"a dead or alive cell\", despite the fact that, when we visualize it, it shows up as red (because it hasn't been marked explicitly to be alive).","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"const Cell = LifeState(1) # this means: a graph with one vertex, nothing else\n\nview_life(Cell) # red color means this cell is not in image of `life` function.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"Let's confirm that this works. Our fancy word for \"pattern match\" is \"homomorphism\" (\"morphism\", for short). To look for morphisms from Cell into G is to ask \"find me all the cells!\". The Catlab function homomorphisms exhaustively finds all such answers to a query like this. When we run it below, we ought see there are 9 answers to this query, as there are 9 vertices in the 3 × 3 grid.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"length(homomorphisms(AddCoords(Cell), G))","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"Our next building block is also a LifeState instance that we think of as a pattern. It is a cell but, furthermore, it is a cell which has been marked as alive. This means it consists in one vertex, one 'life token', and the function live which maps Life₁ to V₁.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"const LiveCell = @acset LifeState begin V=1; Life=1; live=1 end\n\nview_life(LiveCell) # green color means this cell is in image of `life` function","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"Let's confirm that this works.  If we look for morphisms from LiveCell into G, meaning \"find me all the live cells!\", we will see there are 5 answers to this query","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"length(homomorphisms(AddCoords(LiveCell), G))","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"Now we will see our first morphism that is not between some pattern and some world state but, rather, is between our the two previous patterns. A morphism from Cell is an answer to the query \"give me a Cell!\" and there is exactly one possible answer to that query in LiveCell, thus we can use homomorphism, which returns an arbitrary morphism from the set of morphisms computed by homomorphisms.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"to_life is an important morphism to understand as it is the fundamental \"engine\" of the Game of Life. When read 'forwards', it expresses the idea of taking a vertex and adding a Life token to it. When read 'backwards', it expresses the idea of removing a Life token from a vertex. This is all we actually do when simulating the Game of Life: we toggle cells between being marked as alive vs no longer being marked as alive.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"const to_life = homomorphism(Cell, LiveCell);\nnothing #hide","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"The remaining challenge is to control the circumstances under which we perform this fundamental action of toggling life status. This is done via a technique called \"Positive (resp. negative) application conditions\". An application condition is a way of embedding a small pattern in a larger pattern (a context) with the assertion that, for a specific match of the small pattern in a world state, that this context is required (resp. forbidden) to hold.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"Here the small pattern, the large pattern, and the world state will all be LifeState instances. And the the 'embedding' of the small pattern into the large pattern as well as the match of the small pattern in the world will both be morphisms between LifeState instances.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"The following lines of code provide shorthand names for positive and negative applications. The use of the keyword monic can be ignored if this is your first time looking at AlgebraicJulia code. If not, the keyword indicates that the morphism (from the larger context to the world state, used to determine whether the application condition is satisfied) is required to be monic.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"PAC(m) = AppCond(m; monic=true) # Positive Application condition\nNAC(m) = AppCond(m, false; monic=true); # Negative Application condition\nnothing #hide","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"The following line provides a shorthand for constructing the fundamental building block of an ABM, which is an ABMRule. Such a rule requires a name, an instance of a rewrite Rule object from AlgebraicRewriting, as well as a timer which indicates the frequency at which the rule fires. All three of our rules will fire at every tick in time.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"TickRule(name, I_L, I_R; ac) = # Rule which fires on 1.0, 2.0, ...\n  ABMRule(name, Rule(I_L, I_R; ac), DiscreteHazard(1));\nnothing #hide","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"The context for determining whether the rules of underpopulation, overpopulation, or birth apply are always framed in terms of \"how many living neighbors do you have?\". Thus, it is helpful to have function which creates a context of n living neighbors which we can use with various values of n.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"Providing a context for a pattern is more than just giving an instance of LifeState; we also have to say how the pattern relates to the context. So our pattern here is either a vertex (if alive=false) or a vertex marked as alive (alive=true, which is the default value). This morphism data is what allows us to pick out the center vertex as the relevant starting point when checking if a particular match (which is a choice of a vertex in the game state) actually exists with that context of n living living neighbors.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"When we visualize the result of this function below, we're only visualizing the codomain of the morphism (i.e. what the morphism is pointing to).","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"function living_neighbors(n::Int; alive=true)::ACSetTransformation\n  X = LifeState(1) # hide\n  alive && add_part!(X, :Life, live=1) # hide\n  for _ in 1:n # hide\n    v = add_part!(X, :V) # hide\n    add_part!(X, :Life, live=v) # hide\n    add_edge!(X, v, 1) # hide\n  end # hide\n  homomorphism(alive ? LiveCell : Cell, X; initial=(V=[1],)) # hide\nend; # hide\n\nview_life(codom(living_neighbors(3; alive=false)))","category":"page"},{"location":"generated/game_of_life/#Create-model-by-defining-update-rules","page":"Conway's Game of Life","title":"Create model by defining update rules","text":"","category":"section"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"We now have our building blocks in place and can build the three rules.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"A rewrite rule is given by a pair of morphisms, L ← I → R. The first morphism is 'read backwards' (thought of as deletion), and the second one is 'read forwards' (thought of as addition). When one's rule does pure addition, the first morphism is an identity map. Likewise when one's rule does pure deletion, the second morphism is an identity map. So rules underpop and overpop will have their rule given by first to_life and then id(Cell), whereas the rule birth will first have id(Cell) and then to_life. The real interesting part of these constructions then is their application conditions (given via a keyword argument ac).","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"Let's start with underpopulation: a cell dies due to underpopulation if it has fewer than two living neighbors. So the application condition is a negative application: if we notice a cell has the context of two living neighbors, we should not apply the underpop rule.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"underpop =\n  TickRule(:Underpop, to_life, id(Cell); ac=[NAC(living_neighbors(2))]);\nnothing #hide","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"A cell dies due to overpopulation if it has over 3 living neighbors. So here our condition of applying the death rewrite (i.e. reading the morphism to_life backwards) is a positive application condition. We cannot kill a cell unless, furthermore, that cell is in a context where it has (at least) four living neighbors.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"overpop =\n  TickRule(:Overpop, to_life, id(Cell); ac=[PAC(living_neighbors(4))]);\nnothing #hide","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"The rule for birth is that one must have a dead cell with exactly three living neighbors. Our pattern here is simple a vertex, which could match any cell in the game state! So we need to use multiple application conditions to make sure the cell has at least three neighbors, fewer than four neighbors, and doesn't already have a life token. These three constraints are respectively the three elements of the list below.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"birth = TickRule(:Birth, id(Cell), to_life;\n                 ac=[PAC(living_neighbors(3; alive=false)),\n                     NAC(living_neighbors(4; alive=false)),\n                     NAC(to_life)]); # this rule does NOT apply if cell is alive\nnothing #hide","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"We can now create the model: an ABM is constituted by its transition rules","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"GoL = ABM([underpop, overpop, birth]);\nnothing #hide","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"We wrote an ABM for LifeState, but we want to apply it to G as its initial state. G is not a LifeState, but rather a LifeStateCoords! Luckily, we defined AddCoords earlier which knows how to migrate things in the language of LifeState into the language of LifeStateCoords.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"GoL_coords = AddCoords(GoL);\nnothing #hide","category":"page"},{"location":"generated/game_of_life/#Checking-our-rules-make-sense","page":"Conway's Game of Life","title":"Checking our rules make sense","text":"","category":"section"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"Let's remind ourselves what G looks like","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"view_life(G)","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"This code below counts how many matches a rule has, application conditions considered. It returns the coordinatees of those matches.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"match_coords(f::ACSetTransformation) =  codom(f)[f[:V](1), :coords]\nmatch_coords(rule::ABMRule, X) = match_coords.(get_matches(AddCoords(rule), X));\nnothing #hide","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"Let's calculate which cells will die from underpopulation in the first time step:","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"match_coords(underpop, G)","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"This is right, there are no living cells which have fewer than two living neighbors.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"Now, we see that the center cell dies from overpopulation:","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"match_coords(overpop, G)","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"Below are the coordinates of the four cells that will come to life:","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"match_coords(birth, G)","category":"page"},{"location":"generated/game_of_life/#Running-the-ABM","page":"Conway's Game of Life","title":"Running the ABM","text":"","category":"section"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"This is easy! Pass in our model and our initial state. We optionally could limit the run via some maximum number of steps or time, but this one will achieve steady state within 3 time steps.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"res = run!(GoL_coords, G);\n@test length(res) == 13","category":"page"},{"location":"generated/game_of_life/#View-results","page":"Conway's Game of Life","title":"View results","text":"","category":"section"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"We use view_life to generate a bunch of images capturing the trajectory.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"imgs = view(res, view_life);\nnothing #hide","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"The first image is our starting point.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"imgs[1]","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"The next steps (all taking place at t=1.0) are the four births and one overpopulation death.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"imgs[2]","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"imgs[3]","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"imgs[4]","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"imgs[5]","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"imgs[6]","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"At this point, we move to t=2.0. There are now four cells which are overpopulated.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"imgs[7]","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"imgs[8]","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"imgs[9]","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"imgs[10]","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"In the last step, the remaining four living cells perish due to underpopulation.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"imgs[11]","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"imgs[12]","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"imgs[13]","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"imgs[14]","category":"page"},{"location":"generated/game_of_life/#Bonus:-stochastic-game-of-life","page":"Conway's Game of Life","title":"Bonus: stochastic game of life","text":"","category":"section"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"Rather than having all cells update in lockstep, we could change the probability of firing from a Dirac delta distribution at t=1 to an exponential distribution, where the expected value is firing at t=1. This means cells will update one at a time, as it is almost impossible for two events to occur at the same time. The change involved for this is simply replacing the DiscreteHazard of TickRule with a ContinuousHazard.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"continuous_abm = ABM([ABMRule(r.name, r.rule, ContinuousHazard(1)) for r in GoL_coords.rules])\n\nres = run!(continuous_abm, G; maxevent=5)\nimgs = view(res, view_life);\nnothing #hide","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"Here is our starting point.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"imgs[1]","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"Let's look at the next few steps.","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"imgs[2]","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"Then","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"imgs[3]","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"Then","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"imgs[4]","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"","category":"page"},{"location":"generated/game_of_life/","page":"Conway's Game of Life","title":"Conway's Game of Life","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/#Library-Reference","page":"Library Reference","title":"Library Reference","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"Modules = [\n  AlgebraicABMs.Distributions,\n  AlgebraicABMs.ABMs,\n]","category":"page"},{"location":"api/#AlgebraicABMs.Distributions.weibullpar-Tuple{Any, Any}","page":"Library Reference","title":"AlgebraicABMs.Distributions.weibullpar","text":"Get the shape and scale parameters for a Weibull distribution with a given mean and variance. This code is a translation of the R \"mixdist\" package's  function\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicABMs.ABMs.ABM","page":"Library Reference","title":"AlgebraicABMs.ABMs.ABM","text":"An agent-based model.\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicABMs.ABMs.ABMFlow","page":"Library Reference","title":"AlgebraicABMs.ABMs.ABMFlow","text":"Continuous dynamics \n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicABMs.ABMs.ABMRule","page":"Library Reference","title":"AlgebraicABMs.ABMs.ABMRule","text":"A stochastic rewrite rule with a dependent hazard rate\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicABMs.ABMs.AbsDynamics","page":"Library Reference","title":"AlgebraicABMs.ABMs.AbsDynamics","text":"A type which implements AbsDynamics must be able to compiled to an ODE for some  set of variables.\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicABMs.ABMs.AbsHomSet","page":"Library Reference","title":"AlgebraicABMs.ABMs.AbsHomSet","text":"A collection of timers associated at runtime w/ an ABMRule\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicABMs.ABMs.AbsTimer","page":"Library Reference","title":"AlgebraicABMs.ABMs.AbsTimer","text":"Something that can produce a ACSetTransformation × clocktime → hazard_rate\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicABMs.ABMs.ClosureState","page":"Library Reference","title":"AlgebraicABMs.ABMs.ClosureState","text":"A closure which accepts a match morphism and returns a hazard_rate. This is a  timer which cannot depend on the absolute clock time.\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicABMs.ABMs.ClosureTime","page":"Library Reference","title":"AlgebraicABMs.ABMs.ClosureTime","text":"A closure which accepts a clocktime and returns a hazard_rate. This is a timer  which cannot depend on the match data nor ACSet state.\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicABMs.ABMs.EmptyP","page":"Library Reference","title":"AlgebraicABMs.ABMs.EmptyP","text":"Empty patterns have (one) trivial pattern match\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicABMs.ABMs.FullClosure","page":"Library Reference","title":"AlgebraicABMs.ABMs.FullClosure","text":"A closure which accepts a ACSetTransformation and returns a function of type clocktime → hazard_rate\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicABMs.ABMs.RawODE","page":"Library Reference","title":"AlgebraicABMs.ABMs.RawODE","text":"Use raw Julia functions to define an ODE\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicABMs.ABMs.RegularP","page":"Library Reference","title":"AlgebraicABMs.ABMs.RegularP","text":"Default case, where pattern matches should be found via (incremental)  homomorphism search and represented explicitly, each with own events getting  scheduled.\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicABMs.ABMs.RepresentableP","page":"Library Reference","title":"AlgebraicABMs.ABMs.RepresentableP","text":"A pattern match from a coproduct of representables is just a choice of parts in the codomain. E.g. matching L = •→• • •  is just a random choice of edge and two random vertices.\n\nThe vector of ints refers to parts of L which are the counits of the left kan  extensions that define the representables (usually this is just wherever the  colimit leg sends 1, as there is often just one X part in the representable X).\n\nWARNING: this is only viable if the timer associated with the rewrite rule is symmteric with respect to the disjoint representables and has a simple exponential timer.\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicABMs.ABMs.RuntimeABM","page":"Library Reference","title":"AlgebraicABMs.ABMs.RuntimeABM","text":"Data @structhashequal structure for maintaining simulation information while running an ABM\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicABMs.ABMs.Traj","page":"Library Reference","title":"AlgebraicABMs.ABMs.Traj","text":"A trajectory of an ABM: each event time and result of save.\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicABMs.ABMs.init_homset-Tuple{ABMRule, ACSets.ACSetInterface.ACSet, Vector{<:Catlab.CategoricalAlgebra.CSets.ACSetTransformation}}","page":"Library Reference","title":"AlgebraicABMs.ABMs.init_homset","text":"Initialize runtime hom-set given the rule and the initial state\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicABMs.ABMs.is_exp-Tuple{ContinuousHazard}","page":"Library Reference","title":"AlgebraicABMs.ABMs.is_exp","text":"Check if a hazard rate is a simple exponential\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicABMs.ABMs.mk_prob-Tuple{ABM, ACSets.ACSetInterface.ACSet}","page":"Library Reference","title":"AlgebraicABMs.ABMs.mk_prob","text":"Construct an ODE for a given ACSet state. Return a mapping which allows to go from index to AttrType+index. \n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicABMs.ABMs.pattern_type-Tuple{AlgebraicRewriting.Rewrite.Utils.Rule, Bool}","page":"Library Reference","title":"AlgebraicABMs.ABMs.pattern_type","text":"Analyze a pattern to find the most efficient pattern type for it.\n\nBecause ACSet types do not know their own equations, we may have to pass the  schema as an argument in order to compute representables that would otherwise  be infinite.\n\nEven if the pattern is a coproduct of representables, we cannot use the  efficient encoding unless the distribution is either an exponential  (or a single dirac delta - not yet supported).\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicABMs.ABMs.run!-Union{Tuple{T}, Tuple{ABM, T}} where T<:ACSets.ACSetInterface.ACSet","page":"Library Reference","title":"AlgebraicABMs.ABMs.run!","text":"Run an ABM, creating a fresh runtime + trajectory.\n\nsave - function applied to the ACSet state to produce the data that gets stored for every change in the model dt - timestep for checking discrete events when running ODE dynamics.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicABMs.ABMs.validate-Tuple{AlgebraicABMs.ABMs.RuntimeABM}","page":"Library Reference","title":"AlgebraicABMs.ABMs.validate","text":"Check that RuntimeABM incremental hom sets have all valid homs.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicABMs.Upstream.pops!-Tuple{AlgebraicABMs.ABMs.RuntimeABM}","page":"Library Reference","title":"AlgebraicABMs.Upstream.pops!","text":"Pop the next random event, advance the clock\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicRewriting.Rewrite.Utils.get_match-Tuple{AlgebraicABMs.ABMs.EmptyP, ACSets.ACSetInterface.ACSet, ACSets.ACSetInterface.ACSet, AlgebraicABMs.ABMs.EmptyHomSet, Nothing}","page":"Library Reference","title":"AlgebraicRewriting.Rewrite.Utils.get_match","text":"Get match returns a randomly chosen morphism for the aggregate rule\n\n\n\n\n\n","category":"method"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"EditURL = \"../../literate/lotka_volterra.jl\"","category":"page"},{"location":"generated/lotka_volterra/#Lokta-Volterra,-predator-prey-model","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"","category":"section"},{"location":"generated/lotka_volterra/#Set-up","page":"Lokta-Volterra, predator-prey model","title":"Set-up","text":"","category":"section"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"The first step of running a Julia program is to load the external libraries one will be using. We do this with a using statement.","category":"page"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"using AlgebraicABMs, Catlab, AlgebraicRewriting, DataMigrations\nusing Test, Random\nusing Catlab.Graphics.Graphviz: Attributes, Statement, Node # hide\nusing Catlab.Graphics.Graphviz # hide\nENV[\"JULIA_DEBUG\"] = \"AlgebraicABMs\"; # hide\nnothing #hide","category":"page"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"We can also define some shorthand for some long function names","category":"page"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"const hom = homomorphism\nconst homs = homomorphisms\nconst Var = AttrVar;\nRandom.seed!(123); # hide\nnothing #hide","category":"page"},{"location":"generated/lotka_volterra/#Schema","page":"Lokta-Volterra, predator-prey model","title":"Schema","text":"","category":"section"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"Defining a schema is stating what data is required to specify a state of the simulation at some point in time. In AlgebraicJulia, this is done via declaring a Presentation, i.e. a database schema. Objects (Ob, or tables) are types of entities. Homs (Hom, or foreign keys) are functional relationships between the aforementioned entities. AttrTypes are placeholders for Julia types, which are assigned to objects via attributes (Attr).","category":"page"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"The schema below extends the schema for symmetric graphs, which consists in two tables (E and V, for edges and vertices), a hom inv which pairs each edge with its symmetric dual edge, and homs (src, tgt) which relate the edges to the vertices. This extension is indicated by the subtype operator <: SchSymmetricGraph. Here we add a notion of cardinal direction to a symmetric graph, encoding that left and right are inverses and that four rotations does nothing. Edges are all assigned a cardinal direction.","category":"page"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"These schemas don't yet have the capacity to express constraints such as \"each vertex has exactly four incident edges, one of each cardinal direction\", but future versions of Catlab will be able to do this. For now, this is a property we will enforce when we create grids.","category":"page"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"@present SchGrid <: SchSymmetricGraph begin\n  Direction::Ob\n  dir::Hom(E, Direction)\n  left::Hom(Direction, Direction)\n  right::Hom(Direction, Direction)\n  left⋅left⋅left⋅left == id(Direction)\n  right⋅left == id(Direction)\n  left⋅right == id(Direction)\n  inv⋅dir == dir⋅left⋅left\nend;\n\n@acset_type Grid(SchGrid) <: AbstractSymmetricGraph; # Create LV datatype\nnothing #hide","category":"page"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"We now want to allow wolves and sheep to live on the vertices of this grid as well as be oriented in a particular direction.","category":"page"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"@present SchWS <: SchGrid begin\n  (Wolf, Sheep)::Ob\n  wolf_loc::Hom(Wolf, V)\n  sheep_loc::Hom(Sheep, V)\n  wolf_dir::Hom(Wolf,Direction)\n  sheep_dir::Hom(Sheep,Direction)\nend;\nnothing #hide","category":"page"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"A set of time counters are associated with vertices via \"countdown\" which tracks how long it takes until the grass is ready to eat at a location.","category":"page"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"@present SchWSG <: SchWS begin\n  Time::Ob\n  countdown::Hom(Time, V)\nend;\nnothing #hide","category":"page"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"The animals have an \"energy\", drained by moving and reproduction, gained via eating food.","category":"page"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"@present SchLV <: SchWSG begin\n  Eng::AttrType\n  wolf_eng::Attr(Wolf, Eng)\n  sheep_eng::Attr(Sheep, Eng)\nend;\n\n@acset_type LV(SchLV){Int} <: AbstractSymmetricGraph # Create LV datatype\n\nto_graphviz(SchLV; prog=\"dot\")","category":"page"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"We can further extend this schema with an additional attribute of (x,y) coordinates for every vertex. This is nice for visualization but is otherwise unnecessary when doing the actual agent-based modeling. We can also add names to the directions for convenience.","category":"page"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"So what we will do is build our model with the LV schema and then run our model with the LV_viz schema.","category":"page"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"@present SchLV_Viz <: SchLV begin\n  (Coord, Name)::AttrType\n  coord::Attr(V, Coord)\n  dirname::Attr(Direction, Name)\nend\n\n@acset_type LV_Viz(SchLV_Viz){Int, Tuple{Int,Int}, String} <: AbstractSymmetricGraph\n\nconst LV′ = Union{LV, LV_Viz};\nnothing #hide","category":"page"},{"location":"generated/lotka_volterra/#Initializing-and-visualizing-world-states","page":"Lokta-Volterra, predator-prey model","title":"Initializing and visualizing world states","text":"","category":"section"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"To help us create initial states for simulations, a (hidden) helper function that makes an n × n grid with periodic boundary conditions. One edge in each cardinal direction originates at every point.","category":"page"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"function create_grid(n::Int)::LV_Viz\n  lv, coords = LV_Viz(), Dict{Pair{Int,Int}, Int}() # hide\n  N, W, S, E = add_parts!(lv, :Direction, 4; left=[2,3,4,1], right=[4,1,2,3], # hide\n                          dirname=[\"N\",\"W\",\"S\",\"E\"]) # hide\n  for i in 0:n-1, j in 0:n-1 # hide\n    coords[i=>j] = add_vertex!(lv; coord=(i,j)) # hide\n    add_parts!(lv, :Time, max(0, rand(-30:30)); countdown=coords[i=>j]) # hide\n  end # hide\n  for i in 0:n-1, j in 0:n-1 # hide\n    _, e = add_edge!(lv, coords[i=>j], coords[mod(i + 1, n)=>j]; dir=E) # hide\n    lv[lv[e,:inv], :dir] = W # hide\n    _, e = add_edge!(lv, coords[i=>j], coords[i=>mod(j + 1, n)]; dir=N) # hide\n    lv[lv[e,:inv], :dir] = S # hide\n  end # hide\n  return lv # hide\nend; # hide\nnothing #hide","category":"page"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"To initialize a state of the world with sheep and wolves, we also accept parameters which indicate the fraction of spaces that are populated with that animal.","category":"page"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"function initialize(n::Int, sheep::Float64, wolves=nothing)::LV_Viz\n  wolves = isnothing(wolves) ? sheep : wolves # hide\n  grid = create_grid(n) # hide\n  args = [(sheep, :Sheep, :sheep_loc, :sheep_eng, :sheep_dir), # hide\n    (wolves, :Wolf, :wolf_loc, :wolf_eng, :wolf_dir)] # hide\n  for (n_, name, loc, eng, d) in args, _ in 1:round(Int, n_ * n^2) # hide\n    dic = Dict([eng => 5, loc => rand(vertices(grid)),  d => rand(1:4)]) # hide\n    add_part!(grid, name; dic...) # hide\n  end # hide\n  return grid # hide\nend; # hide\nnothing #hide","category":"page"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"Some visualization code below will allow us to see states of the world. Edges are left implicit (we know from how the graphs were constructed that there are edges between every pair of adjacent vertices).","category":"page"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"supscript_d = Dict(zip(\"1234567890xyzabcd\", \"¹²³⁴⁵⁶⁷⁸⁹⁰ˣʸᶻᵃᵇᶜᵈ\")) # hide\nsupscript(x::String) = join([get(supscript_d, c, c) for c in x]); # hide\n\nfunction view_LV(p::LV′, pth=tempname(); name=\"G\", title=\"\")\n  pstr = [\"$(i),$(j)!\" for (i, j) in p[:coord]] # hide\n  stmts = Statement[] # hide\n  for s in 1:nv(p) # hide\n    gv = length(incident(p, s, :countdown)) # hide\n    col = gv == 0 ? \"lightgreen\" : \"tan\" # hide\n    push!(stmts, Node(\"v$s\", Attributes( # hide\n      :label => gv == 0 ? \"\" : string(gv), :shape => \"circle\", # hide\n      :color => col, :pos => pstr[s]))) # hide\n  end # hide\n  d = Dict(\"E\" => (1, 0), \"N\" => (0, 1), \"S\" => (0, -1), \"W\" => (-1, 0)) # hide\n\n  args = [(:true, :Wolf, :wolf_loc, :wolf_eng, :wolf_dir), # hide\n    (false, :Sheep, :sheep_loc, :sheep_eng, :sheep_dir)] # hide\n\n  for (is_wolf, prt, loc, eng, dr) in args, agent in parts(p, prt) # hide\n    e = only(incident(p, p[agent, loc], :src) ∩ incident(p, p[agent, dr], :dir)) # hide\n    dx, dy = d[p[e, [:dir, :dirname]]] # hide\n    (sx, sy) = p[src(p, e), :coord] # hide\n\n    L, R = 0.25, 0.1 # hide\n    wx = sx + L * dx + R * rand() # hide\n    wy = sy + L * dy + R * rand() # hide\n    ID = \"$(is_wolf ? :w : :s)$agent\" # hide\n    append!(stmts, [Node(ID, Attributes( # hide\n      :label => \"$agent\" * supscript(\"$(p[agent,eng])\"), # hide\n      :shape => \"square\", :width => \"0.3px\", :height => \"0.3px\", :fixedsize => \"true\", # hide\n      :pos => \"$(wx),$(wy)!\", :color => is_wolf ? \"red\" : \"lightblue\"))]) # hide\n  end # hide\n\n  g = Graphviz.Digraph(name, Statement[stmts...]; prog=\"neato\", # hide\n    graph_attrs=Attributes(:label => title, :labelloc => \"t\"), # hide\n    node_attrs=Attributes(:shape => \"plain\", :style => \"filled\")) # hide\n  open(pth, \"w\") do io # hide\n    show(io, \"image/svg+xml\", g) # hide\n  end # hide\n  return g # hide\nend; # hide\nnothing #hide","category":"page"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"We can use this to visualize an example","category":"page"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"init = initialize(2, 0.5)\nview_LV(init)","category":"page"},{"location":"generated/lotka_volterra/#Data-migration-functors","page":"Lokta-Volterra, predator-prey model","title":"Data migration functors","text":"","category":"section"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"The schema LV has a certain symmetry between wolves and sheep, and this symmetry can be used to take instances of the schema (i.e. world states) and swap the wolves and the sheep. This is helpful for avoiding repeating work: there are certain actions that wolves and sheep share, so, by using this data migration, we can define them in terms of sheep and then migrate along F to obtain the analogous actions for wolves.","category":"page"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"F = Migrate(\n  Dict(:Sheep => :Wolf, :Wolf => :Sheep),\n  Dict([:sheep_loc => :wolf_loc, :wolf_loc => :sheep_loc,\n    :sheep_eng => :wolf_eng, :wolf_eng => :sheep_eng, :countdown => :countdown,\n    :sheep_dir => :wolf_dir, :wolf_dir => :sheep_dir,]), SchLV, LV);\nnothing #hide","category":"page"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"We ought to be able to take a state of the world (with no coordinate information) and obtain a state of the world with coordinates (the canonical way to do this is to assign \"variables\" for the values of the coordinates).","category":"page"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"Viz = Migrate(SchLV, LV, SchLV_Viz, LV_Viz; delta=false);\nnothing #hide","category":"page"},{"location":"generated/lotka_volterra/#Representables","page":"Lokta-Volterra, predator-prey model","title":"Representables","text":"","category":"section"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"We want to say \"give me a sheep\" or \"give me a sheep and a wolf that are on the same vertex\" and have it automatically specify the remaining information in the most generic way possible. The @acset_colim macro is perfect for exactly this. In order to use that macro, we need to precompute the yoneda_cache.","category":"page"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"yLV = yoneda_cache(LV);\nI = LV() # Empty agent type\nS = @acset_colim yLV begin s::Sheep end # Generic sheep agent\nE = @acset_colim yLV begin e::E end # Generic edge\nEng = @acset_colim yLV begin e::Eng end # Free floating energy unit\nD = @acset_colim yLV begin D::Direction end # Generic cardinal directions\nW = F(S) # Generic wolf agent, obtained via the swapping `F` data migration\nG = @acset_colim yLV begin v::V end; # Generic grass agent (i.e. vertex)\nnothing #hide","category":"page"},{"location":"generated/lotka_volterra/#Rules","page":"Lokta-Volterra, predator-prey model","title":"Rules","text":"","category":"section"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"We have finished specifying what makes up a simulation state, and next is to define what sorts of transitions are possible. This is done by declaring rewrite rules.","category":"page"},{"location":"generated/lotka_volterra/#Rotating","page":"Lokta-Volterra, predator-prey model","title":"Rotating","text":"","category":"section"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"Our first action that is possible for sheep (and wolves) is rotation. Animals will, with some probability, change their orientation. This is a rewrite rule which only modifies an attribute rather than changing any combinatorial data, so rather than the usual span L ← I → R data required we simply put in a single ACSet along with an expr dictionary which states how attributes change.","category":"page"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"DVS_N, DVS_E, DVS_W, _ = homs(D ⊕ G ⊕ Eng, S; initial=(Eng=[Var(1)],))\nsheep_rl = Rule(DVS_N, DVS_E);\nsheep_rr = Rule(DVS_N, DVS_W);\nnothing #hide","category":"page"},{"location":"generated/lotka_volterra/#Test-rotation","page":"Lokta-Volterra, predator-prey model","title":"Test rotation","text":"","category":"section"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"ex = @acset_colim yLV begin\n  e::E; s::Sheep;\n  sheep_loc(s)==src(e); sheep_eng(s)==100; dir(e)==left(sheep_dir(s))\nend;\n\nexpected = copy(ex);\nexpected[:sheep_dir] = ex[1, :dir] # rotate right aligns the sheep w/ the edge\n\n@test is_isomorphic(rewrite(sheep_rl, ex), expected)","category":"page"},{"location":"generated/lotka_volterra/#Moving-forward","page":"Lokta-Volterra, predator-prey model","title":"Moving forward","text":"","category":"section"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"s_fwd_l = @acset_colim yLV begin\n  e::E; s::Sheep\n  sheep_loc(s) == src(e)\n  dir(e) == sheep_dir(s)\nend\n\ns_fwd_r = @acset_colim yLV begin\n  e::E; s::Sheep; sheep_loc(s) == tgt(e); dir(e) == sheep_dir(s)\nend;\n\nsheep_fwd_rule = Rule(first(homs(E, s_fwd_l; monic=true)),\n                      last(homs(E,  s_fwd_r; monic=true)),\n                      expr=(Eng=[((eₛ,),) -> eₛ - 1],));\nnothing #hide","category":"page"},{"location":"generated/lotka_volterra/#Moving-forward-test","page":"Lokta-Volterra, predator-prey model","title":"Moving forward test","text":"","category":"section"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"ex = @acset_colim yLV begin\n  (e1,e2)::E; (s::Sheep)\n  src(e2)==tgt(e1); sheep_loc(s)==src(e1)\n  sheep_eng(s)==10\n  sheep_dir(s)==dir(e1); dir(e1)==left(dir(e2))\nend\nexpected = copy(ex);\nexpected[1, :sheep_loc] = ex[1, :tgt]\nexpected[1, :sheep_eng] = 9\n\n@test is_isomorphic(expected, rewrite(sheep_fwd_rule, ex))","category":"page"},{"location":"generated/lotka_volterra/#Sheep-eat-grass","page":"Lokta-Volterra, predator-prey model","title":"Sheep eat grass","text":"","category":"section"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"s_eat_N = @acset_colim yLV begin\n  s::Sheep; t::Time; countdown(t) == sheep_loc(s)\nend\ns_eat_L = @acset_colim yLV begin s::Sheep;  end;\ns_eat_R = deepcopy(s_eat_L)\nadd_parts!(s_eat_R, :Time, 30; countdown=1)\nse_left = hom(G⊕D, s_eat_L; initial=(Direction=1:4,))\nse_right = hom(G⊕D, s_eat_R;  initial=(Direction=1:4,))\nse_nac = hom(s_eat_L, s_eat_N)\nse_rule = Rule(se_left, se_right;\n               ac=[AppCond(se_nac, false)], expr=(Eng=[((vₛ,),) -> vₛ + 4],));\nnothing #hide","category":"page"},{"location":"generated/lotka_volterra/#Sheep-eating-test","page":"Lokta-Volterra, predator-prey model","title":"Sheep eating test","text":"","category":"section"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"ex = @acset_colim yLV begin\n  e::E; s::Sheep; t::Time\n  dir(e)==sheep_dir(s); countdown(t)==src(e);\n  sheep_loc(s)==tgt(e); sheep_eng(s) == 3\nend\n\nexpected = copy(ex)\nadd_parts!(expected, :Time, 30; countdown=2)\nexpected[1,:sheep_eng] = 7\n@test is_isomorphic(expected, rewrite(se_rule, ex))","category":"page"},{"location":"generated/lotka_volterra/#Wolves-eat-sheep","page":"Lokta-Volterra, predator-prey model","title":"Wolves eat sheep","text":"","category":"section"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"w_eat_l = @acset_colim yLV begin\n  s::Sheep; w::Wolf; sheep_loc(s) == wolf_loc(w)\nend;\n\nwe_left = hom(G⊕D⊕D, w_eat_l; initial=(Direction=Dict(1=>1, 5=>5),))\nwe_right = hom(G⊕D⊕D, D⊕W; initial=(Direction=Dict(1=>1, 5=>5),))\nwe_rule = Rule(we_left, we_right;\n               expr=(Eng=[((vₛ, vᵩ),) -> vᵩ + 20],));\nnothing #hide","category":"page"},{"location":"generated/lotka_volterra/#Wolf-eating-test","page":"Lokta-Volterra, predator-prey model","title":"Wolf eating test","text":"","category":"section"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"ex = @acset_colim yLV begin\n  (s::Sheep); (w::Wolf); (e::E); (t1,t2,t3)::Time\n  countdown(t1)==src(e); countdown(t2)==src(e); countdown(t3)==tgt(e)\n  sheep_dir(s)==left(wolf_dir(w))\n  sheep_dir(s)==right(dir(e))\n  sheep_eng(s)==3; wolf_eng(w)==16\n  sheep_loc(s)==tgt(e); wolf_loc(w)==tgt(e)\nend\n\nexpected = copy(ex)\nexpected[1, :wolf_eng] = 36\nrem_part!(expected, :Sheep, 1)\n\n@test is_isomorphic(rewrite(we_rule, ex), expected)","category":"page"},{"location":"generated/lotka_volterra/#Sheep-starvation","page":"Lokta-Volterra, predator-prey model","title":"Sheep starvation","text":"","category":"section"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"s_die_l = @acset_colim yLV begin s::Sheep; sheep_eng(s) == 0 end;\nsheep_die_rule = Rule(hom(G⊕D, s_die_l; any=true), id(G⊕D));\nnothing #hide","category":"page"},{"location":"generated/lotka_volterra/#Sheep-starvation-test","page":"Lokta-Volterra, predator-prey model","title":"Sheep starvation test","text":"","category":"section"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"ex = @acset_colim yLV begin\n  s::Sheep; w::Wolf; (t,t2)::Time\n  countdown(t)==sheep_loc(s); countdown(t2)==wolf_loc(w)\n  sheep_eng(s)==0; wolf_eng(w)==10; sheep_dir(s) == right(wolf_dir(w))\nend\nexpected = copy(ex)\nrem_part!(expected, :Sheep, 1)\n\n@test is_isomorphic(rewrite(sheep_die_rule,ex), expected)","category":"page"},{"location":"generated/lotka_volterra/#Reproduction","page":"Lokta-Volterra, predator-prey model","title":"Reproduction","text":"","category":"section"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"s_reprod_r = @acset_colim yLV begin\n  (x, y)::Sheep; sheep_loc(x) == sheep_loc(y); sheep_dir(x)==sheep_dir(y)\nend;\n\nsheep_reprod_rule = Rule(\n  hom(G⊕D, S; any=true),\n  hom(G⊕D, s_reprod_r; any=true);\n  expr=(Dir=fill(vs->only(vs) ,2),\n        Eng=fill(vs -> round(Int, vs[1] / 2, RoundUp), 2),)\n);\nnothing #hide","category":"page"},{"location":"generated/lotka_volterra/#Reproduction-test","page":"Lokta-Volterra, predator-prey model","title":"Reproduction test","text":"","category":"section"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"ex = @acset_colim yLV begin\n  s::Sheep; w::Wolf; t::Time\n  countdown(t)==sheep_loc(s);\n  sheep_eng(s)==10; wolf_eng(w)==20; sheep_dir(s) == right(wolf_dir(w))\nend\n\nexpected = copy(ex)\nadd_part!(expected,:Sheep)\nexpected[:sheep_eng] = [5, 5]\nexpected[:sheep_loc] = fill(ex[1,:sheep_loc], 2)\nexpected[:sheep_dir] = fill(ex[1,:sheep_dir], 2)\n\nm = hom(pattern(sheep_reprod_rule),ex)\ncan_match(sheep_reprod_rule, m)\n@test is_isomorphic(rewrite(sheep_reprod_rule,ex),expected)","category":"page"},{"location":"generated/lotka_volterra/#Grass-increments","page":"Lokta-Volterra, predator-prey model","title":"Grass increments","text":"","category":"section"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"g_inc_L = @acset_colim yLV begin t::Time end\nrem_time = hom(G, g_inc_L)\ng_inc_rule = Rule(rem_time, id(G));\nnothing #hide","category":"page"},{"location":"generated/lotka_volterra/#Grass-incrementing-test","page":"Lokta-Volterra, predator-prey model","title":"Grass incrementing test","text":"","category":"section"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"ex = @acset_colim yLV begin\n  e::E; t::Time; countdown(t) == tgt(e)\nend\n\n@test is_isomorphic(rewrite(g_inc_rule, ex), E)","category":"page"},{"location":"generated/lotka_volterra/#Adding-timers-to-the-rules-and-making-the-model","page":"Lokta-Volterra, predator-prey model","title":"Adding timers to the rules and making the model","text":"","category":"section"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"With our possible actions defined, we now need to provide enough information for a simulator to execute the actions in time. A simple way of doing this is to add an exponential waiting time to each action.","category":"page"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"MkRule(args) = ABMRule(args[1], args[2], ContinuousHazard(args[3]))\n\nrules = MkRule.([\n  (:SheepRotateRight, sheep_rr , 1.),\n  (:SheepRotateLeft, sheep_rl , 1.),\n  (:SheepMoveFwd, sheep_fwd_rule, 0.5),\n  (:WolfRotateRight, F(sheep_rr), 1.),\n  (:WolfRotateLeft, F(sheep_rl),1.),\n  (:WolfMoveFwd, F(sheep_fwd_rule), .25),\n  (:SheepStarve, sheep_die_rule, 0.001),\n  (:WolfStarve, F(sheep_die_rule), 0.001),\n  (:SheepReprod, sheep_reprod_rule, 0.5),\n  (:WolfReprod, F(sheep_reprod_rule), 20),\n  (:GrassGrow, g_inc_rule , 1.)])\n\n\nabm = ABM(rules) # this is defined for SchLV, not SchLV_Viz\nabm_viz = Viz(abm);\nnothing #hide","category":"page"},{"location":"generated/lotka_volterra/#Running-the-model","page":"Lokta-Volterra, predator-prey model","title":"Running the model","text":"","category":"section"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"init = initialize(2, 0.25)\n\nres = run!(abm_viz, init; maxevent=3)\nimgs = view(res, view_LV);\nnothing #hide","category":"page"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"The first image is our starting point.","category":"page"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"imgs[1]","category":"page"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"Then the first event","category":"page"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"imgs[2]","category":"page"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"Then the second event","category":"page"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"imgs[3]","category":"page"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"And the third event","category":"page"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"imgs[4]","category":"page"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"","category":"page"},{"location":"generated/lotka_volterra/","page":"Lokta-Volterra, predator-prey model","title":"Lokta-Volterra, predator-prey model","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/sir_petri/","page":"Petri-net based ABMs","title":"Petri-net based ABMs","text":"EditURL = \"../../literate/sir_petri.jl\"","category":"page"},{"location":"generated/sir_petri/#Petri-net-based-ABMs","page":"Petri-net based ABMs","title":"Petri-net based ABMs","text":"","category":"section"},{"location":"generated/sir_petri/","page":"Petri-net based ABMs","title":"Petri-net based ABMs","text":"First we want to load our packages with `using","category":"page"},{"location":"generated/sir_petri/","page":"Petri-net based ABMs","title":"Petri-net based ABMs","text":"using AlgebraicABMs, Catlab\nusing AlgebraicPetri\nusing Distributions, Makie, CairoMakie\nENV[\"JULIA_DEBUG\"] = \"\"; # turn off @debug messages for this package\nnothing #hide","category":"page"},{"location":"generated/sir_petri/","page":"Petri-net based ABMs","title":"Petri-net based ABMs","text":"We define an SIRS model with birth and death","category":"page"},{"location":"generated/sir_petri/","page":"Petri-net based ABMs","title":"Petri-net based ABMs","text":"sir_pn= @acset LabelledPetriNet begin\n  S=3; sname=[:S,:I,:R]\n  T=7; tname=[:inf,:rec,:birth,:deathS,:deathI,:deathR,:wane]\n  I=7; it=[1,1,2,4,5,6,7]; is=[1,2,2,1,2,3,3]\n  O=5; ot=[1,1,2,3,7]; os=[2,2,3,1,1]\nend;\nnothing #hide","category":"page"},{"location":"generated/sir_petri/","page":"Petri-net based ABMs","title":"Petri-net based ABMs","text":"We declare parameters to specify the random waiting times","category":"page"},{"location":"generated/sir_petri/","page":"Petri-net based ABMs","title":"Petri-net based ABMs","text":"pS, pI, pR = 95,5,0\npop = 100\nlifespan = 65*365\nμ = 1/lifespan\nβ = 0.001\nwane = 60;\nnothing #hide","category":"page"},{"location":"generated/sir_petri/","page":"Petri-net based ABMs","title":"Petri-net based ABMs","text":"Create the ABM by associating stochastic timers with each transition","category":"page"},{"location":"generated/sir_petri/","page":"Petri-net based ABMs","title":"Petri-net based ABMs","text":"abm = ABM(sir_pn, (inf=ContinuousHazard(1 / β),\n                   rec=ContinuousHazard(Weibull(weibullpar(30, 5)...)),\n                   birth=ContinuousHazard(1 / (μ*pop)),\n                   deathS=ContinuousHazard(1 / μ),\n                   deathI=ContinuousHazard(1 / μ),\n                   deathR=ContinuousHazard(1 / μ),\n                   wane=ContinuousHazard(wane)));\nnothing #hide","category":"page"},{"location":"generated/sir_petri/","page":"Petri-net based ABMs","title":"Petri-net based ABMs","text":"Initial state","category":"page"},{"location":"generated/sir_petri/","page":"Petri-net based ABMs","title":"Petri-net based ABMs","text":"init = PetriNetCSet(sir_pn; S=pS, I=pI)","category":"page"},{"location":"generated/sir_petri/","page":"Petri-net based ABMs","title":"Petri-net based ABMs","text":"Run the model","category":"page"},{"location":"generated/sir_petri/","page":"Petri-net based ABMs","title":"Petri-net based ABMs","text":"res = run!(abm, init; maxtime=2000);\nnothing #hide","category":"page"},{"location":"generated/sir_petri/","page":"Petri-net based ABMs","title":"Petri-net based ABMs","text":"Plot results","category":"page"},{"location":"generated/sir_petri/","page":"Petri-net based ABMs","title":"Petri-net based ABMs","text":"Makie.plot(res; Dict(o=>X->nparts(X,o) for o in [:S,:I,:R])...)","category":"page"},{"location":"generated/sir_petri/","page":"Petri-net based ABMs","title":"Petri-net based ABMs","text":"","category":"page"},{"location":"generated/sir_petri/","page":"Petri-net based ABMs","title":"Petri-net based ABMs","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#AlgebraicABMs.jl","page":"AlgebraicABMs.jl","title":"AlgebraicABMs.jl","text":"","category":"section"},{"location":"","page":"AlgebraicABMs.jl","title":"AlgebraicABMs.jl","text":"CurrentModule = AlgebraicABMs","category":"page"},{"location":"","page":"AlgebraicABMs.jl","title":"AlgebraicABMs.jl","text":"AlgebraicABMs.jl is a Julia library for creating agent-based models. We ultimate want to provide capabilities on par with software like AnyLogic, NetLogo, and Agents.jl - all while offering a mostly declarative interface such that: ","category":"page"},{"location":"","page":"AlgebraicABMs.jl","title":"AlgebraicABMs.jl","text":"The model's logic is transparent (rather than hidden away in complicated interactions of code blocks)\nModels can be built compositionally (we can naturally 'glue' models together at a high level, without worrying about implementation details and edge-cases)\nModels can be migrated at a high level, whether interpersonally (collaboration with others who have a different ontology/vocabulary) or intrapersonally (one updates one's own model of the of world and wishes to reuse one's old model under new assumptions, without having to manually refactor code and dig into implementation details).","category":"page"}]
}
